<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>3D滚动球 v1.2</title>
    
    <!-- 核心库: Three.js 仍然从稳定的CDN加载 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- 关键修复：将 Cannon-es.js 的代码直接内联到HTML中 -->
    <script>
    // --- BEGIN CANNON-ES.JS LIBRARY CODE (DO NOT EDIT) ---
    /*!
     * cannon-es v0.19.0
     * 
     * Copyright (c) 2020-present, Partick Dahl
     * 
     * This source code is licensed under the MIT license.
     * 
     * Looking for the original cannon.js?
     * Follow this link: https://github.com/schteppe/cannon.js
     */
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).CANNON={})}(this,(function(t){"use strict";var e={};const i={};class s{constructor(t={}){const e=t.friction,i=t.restitution;this.name=s.idCounter++,this.id=this.name,this.friction=void 0!==e?e:.3,this.restitution=void 0!==i?i:.3,this.idCounter=s.idCounter}static idCounter=0}class o{constructor(t,e,i={}){const s=i.friction,o=i.restitution,n=i.contactEquationStiffness,r=i.contactEquationRelaxation,h=i.frictionEquationStiffness,a=i.frictionEquationRelaxation;this.id=o.idCounter++,this.materials=[t,e],this.friction=void 0!==s?s:(t.friction+e.friction)/2,this.restitution=void 0!==o?o:Math.max(t.restitution,e.restitution),this.contactEquationStiffness=void 0!==n?n:1e7,this.contactEquationRelaxation=void 0!==r?r:3,this.frictionEquationStiffness=void 0!==h?h:1e7,this.frictionEquationRelaxation=void 0!==a?a:3}static idCounter=0}class n{constructor(t,e,i){this.x=t||0,this.y=e||0,this.z=i||0}set(t,e,i){return this.x=t,this.y=e,this.z=i,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){return e?e.set(this.x+t.x,this.y+t.y,this.z+t.z):(new n(this.x+t.x,this.y+t.y,this.z+t.z))}vsub(t,e){return e?e.set(this.x-t.x,this.y-t.y,this.z-t.z):(new n(this.x-t.x,this.y-t.y,this.z-t.z))}cross(t,e){const i=t.x,s=t.y,o=t.z,r=this.x,h=this.y,a=this.z;return(e=e||new n).x=h*o-a*s,e.y=a*i-r*o,e.z=r*s-h*i,e}scale(t,e){const i=this.x,s=this.y,o=this.z;return(e=e||new n).x=t*i,e.y=t*s,e.z=t*o,e}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(t){return t=t||new n,t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const i=this.length();if(i>0){const s=i,o=this.x/s,r=this.y/s,h=this.z/s;if(Math.abs(o)<.9)t.set(0,0,1),t.cross(this,t);else e.set(0,1,0),this.cross(e,t);this.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthSquared(){return this.dot(this)}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s}normalize(){const t=this.length();if(t>0){const e=1/t;this.x*=e,this.y*=e,this.z*=e}return t}clone(){return new n(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,i){const s=this.x,o=this.y,r=this.z;return i.x=s+(t.x-s)*e,i.y=o+(t.y-o)*e,i.z=r+(t.z-r)*e,i}almostEquals(t,e=1e-6){return!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t=1e-6){return!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e=1e-6){const i=new n;return this.negate(i),i.almostEquals(t,e)}}const r={};class h{constructor(t,e,i,s){this.x=t||0,this.y=e||0,this.z=i||0,this.w=void 0!==s?s:1}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}setFromAxisAngle(t,e){const i=Math.sin(.5*e);this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(.5*e);return this}toAxisAngle(t){t=t||new n;const e=this.w;if(e>1||e<-1){this.normalize();return[t,0]}const i=2*Math.acos(e),s=Math.sqrt(1-e*e);return s<.001?t.set(this.x,this.y,this.z):(t.x=this.x/s,t.y=this.y/s,t.z=this.z/s),[t,i]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const i=new n(1,0,0);t.almostEquals(i,1e-5)||t.almostEquals(i.negate(),1e-5)?i.set(0,1,0):i.set(1,0,0),this.setFromAxisAngle(i,Math.PI)}else{const i=t.cross(e);this.x=i.x,this.y=i.y,this.z=i.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}inverse(t){const e=this.x,i=this.y,s=this.z,o=this.w;t=t||new h;const n=e*e+i*i+s*s+o*o;return t.x=-e/n,t.y=-i/n,t.z=-s/n,t.w=o/n,t}conjugate(t){return t=t||new h,t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){const t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);0===t?this.x=this.y=this.z=this.w=0:(this.x/=t,this.y/=t,this.z/=t,this.w/=t)}vmult(t,e){e=e||new n;const i=t.x,s=t.y,o=t.z,r=this.w,h=this.x,a=this.y,l=this.z,c=r*i+a*o-l*s,d=r*s+l*i-h*o,u=r*o+h*s-a*i,p=-h*i-a*s-l*o;return e.x=c*r+p*-h+d*-l-u*-a,e.y=d*r+p*-a+u*-h-c*-l,e.z=u*r+p*-l+c*-a-d*-h,e}mult(t,e){e=e||new h;const i=this.w,s=this.x,o=this.y,n=this.z,r=t.w,a=t.x,l=t.y,c=t.z;return e.x=s*r+i*a+o*c-n*l,e.y=o*r+i*l+n*a-s*c,e.z=n*r+i*c+s*l-o*a,e.w=i*r-s*a-o*l-n*c,e}toEuler(t,e="XYZ"){let i,s,o,n=this.x,r=this.y,h=this.z,a=this.w;switch(e){case"YZX":{const t=2*(r*h+n*a);1-t*t<1e-6?t>0?(i=0,s=Math.PI/2,o=2*Math.atan2(r,a)):(i=0,s=-Math.PI/2,o=-2*Math.atan2(r,a)):(s=Math.asin(t),o=Math.atan2(2*(r*a-n*h),1-2*(r*r+n*n)),i=Math.atan2(2*(h*a-n*r),1-2*(h*h+n*n)));break}case"ZXY":{const t=2*(n*r-h*a);1+t*t<1e-6?t>0?(i=Math.PI/2,s=0,o=2*Math.atan2(n,a)):(i=-Math.PI/2,s=0,o=-2*Math.atan2(n,a)):(i=Math.asin(-t),s=Math.atan2(2*(r*a+n*h),1-2*(r*r+h*h)),o=Math.atan2(2*(n*a+r*h),1-2*(n*n+h*h)));break}case"YXZ":{const t=2*(r*a-n*h);1-t*t<1e-6?t>0?(i=Math.PI/2,s=2*Math.atan2(n,a),o=0):(i=-Math.PI/2,s=-2*Math.atan2(n,a),o=0):(i=Math.asin(t),s=Math.atan2(2*(n*a+r*h),1-2*(n*n+r*r)),o=Math.atan2(2*(h*a+n*r),1-2*(h*h+r*r)));break}case"ZYX":{const t=2*(r*h-n*a);1+t*t<1e-6?t>0?(i=0,s=2*Math.atan2(h,a),o=-Math.PI/2):(i=0,s=-2*Math.atan2(h,a),o=Math.PI/2):(o=Math.asin(-t),i=Math.atan2(2*(n*a+r*h),1-2*(n*n+h*h)),s=Math.atan2(2*(h*a+n*r),1-2*(h*h+r*r)));break}case"XZY":{const t=2*(n*a-r*h);1+t*t<1e-6?t>0?(i=2*Math.atan2(r,a),s=-Math.PI/2,o=0):(i=-2*Math.atan2(r,a),s=Math.PI/2,o=0):(s=Math.asin(-t),i=Math.atan2(2*(r*a+n*h),1-2*(r*r+h*h)),o=Math.atan2(2*(h*a+n*r),1-2*(n*n+h*h)));break}default:{const t=2*(n*r+h*a);1-t*t<1e-6?t>0?(i=Math.PI/2,s=0,o=2*Math.atan2(n,a)):(i=-Math.PI/2,s=0,o=-2*Math.atan2(n,a)):(i=Math.asin(t),s=Math.atan2(2*(r*a-n*h),1-2*(r*r+h*h)),o=Math.atan2(2*(n*a-r*h),1-2*(n*n+h*h)))}t.x=i,t.y=s,t.z=o}return this}setFromEuler(t,e,i,s="XYZ"){const o=Math.cos(t/2),n=Math.cos(e/2),r=Math.cos(i/2),a=Math.sin(t/2),l=Math.sin(e/2),c=Math.sin(i/2);switch(s){case"XYZ":this.x=a*n*r+o*l*c,this.y=o*l*r-a*n*c,this.z=o*n*c+a*l*r,this.w=o*n*r-a*l*c;break;case"YXZ":this.x=a*n*r+o*l*c,this.y=o*l*r-a*n*c,this.z=o*n*c-a*l*r,this.w=o*n*r+a*l*c;break;case"YXZ":this.x=a*n*r-o*l*c,this.y=o*l*r+a*n*c,this.z=o*n*c+a*l*r,this.w=o*n*r-a*l*c;break;case"YZX":this.x=a*n*r-o*l*c,this.y=o*l*r+a*n*c,this.z=o*n*c-a*l*r,this.w=o*n*r+a*l*c;break;case"ZXY":this.x=a*n*r+o*l*c,this.y=o*l*r+a*n*c,this.z=o*n*c-a*l*r,this.w=o*n*r-a*l*c;break;case"ZYX":this.x=a*n*r-o*l*c,this.y=o*l*r-a*n*c,this.z=o*n*c+a*l*r,this.w=o*n*r+a*l*c;break;default:throw new Error(`Euler order ${s} not supported.`)}return this}clone(){return new h(this.x,this.y,this.z,this.w)}slerp(t,e,i){const s=this.x,o=this.y,n=this.z,r=this.w,a=t.x,l=t.y,c=t.z,d=t.w;let u,p,f,m,g;if(p=s*a+o*l+n*c+r*d,p<0&&(p=-p,g=new h(-a,-l,-c,-d)),u=1-p,u>1e-6){const t=Math.sqrt(u),i=Math.sin(u)*1/t;f=Math.sin((1-e)*t)*i,m=Math.sin(e*t)*i}else f=1-e,m=e;return i.x=f*s+m*g.x,i.y=f*o+m*g.y,i.z=f*n+m*g.z,i.w=f*r+m*g.w,i}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}integrate(t,e,i,s){const o=t.x*i.x,n=t.y*i.y,r=t.z*i.z,a=this.x,l=this.y,c=this.z,d=this.w;let u=.5*e;return s.x+=(u*o)*d+(u*n)*-c+(u*r)*l,s.y+=(u*o)*c+(u*n)*d+(u*r)*-a,s.z+=(u*o)*-l+(u*n)*a+(u*r)*d,s.w+=-(u*o)*a-(u*n)*l-(u*r)*c,s}}const a={};class l{constructor(t={}){this.elements=t,t||(this.elements=[0,0,0,0,0,0,0,0,0])}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){t=t||new n;const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){e=e||new n;const i=this.elements,s=t.x,o=t.y,r=t.z;return e.x=i[0]*s+i[1]*o+i[2]*r,e.y=i[3]*s+i[4]*o+i[5]*r,e.z=i[6]*s+i[7]*o+i[8]*r,e}mmult(t,e){e=e||new l;const i=this.elements,s=t.elements,o=e.elements,n=i[0],r=i[1],h=i[2],a=i[3],c=i[4],d=i[5],u=i[6],p=i[7],f=i[8],m=s[0],g=s[1],y=s[2],v=s[3],C=s[4],w=s[5],b=s[6],S=s[7],x=s[8];return o[0]=n*m+r*v+h*b,o[1]=n*g+r*C+h*S,o[2]=n*y+r*w+h*x,o[3]=a*m+c*v+d*b,o[4]=a*g+c*C+d*S,o[5]=a*y+c*w+d*x,o[6]=u*m+p*v+f*b,o[7]=u*g+p*C+f*S,o[8]=u*y+p*w+f*x,e}scale(t,e){e=e||new l;const i=this.elements,s=e.elements,o=t.x,n=t.y,r=t.z;return s[0]=o*i[0],s[1]=o*i[1],s[2]=o*i[2],s[3]=n*i[3],s[4]=n*i[4],s[5]=n*i[5],s[6]=r*i[6],s[7]=r*i[7],s[8]=r*i[8],e}transpose(t){t=t||new l;const e=this.elements,i=t.elements,s=e[1],o=e[2],n=e[5];return i[0]=e[0],i[1]=e[3],i[2]=e[6],i[3]=s,i[4]=e[4],i[5]=e[7],i[6]=o,i[7]=n,i[8]=e[8],t}setRotationFromQuaternion(t){const e=t.x,i=t.y,s=t.z,o=t.w,n=e+e,r=i+i,h=s+s,a=e*n,l=e*r,c=e*h,d=i*r,u=i*h,p=s*h,f=o*n,m=o*r,g=o*h,y=this.elements;return y[0]=1-d-p,y[1]=l-g,y[2]=c+m,y[3]=l+g,y[4]=1-a-p,y[5]=u-f,y[6]=c-m,y[7]=u+f,y[8]=1-a-d,this}copy(t){const e=this.elements,i=t.elements;for(let t=0;t<i.length;t++)e[t]=i[t];return this}}class c{constructor(t={}){const{position:e,quaternion:i,velocity:s,angularVelocity:o,axis:r,angle:a}=t;this.position=e?e.clone():new n,this.quaternion=i?i.clone():new h,s&&(this.velocity=s.clone()),o&&(this.angularVelocity=o.clone()),r&&this.quaternion.setFromAxisAngle(r,a)}}const d={};class u{constructor(t,e,i,s,o){super(t,e),this.contactPoint=i,this.penetration=s,this.normal=o}}class p{constructor(t,e,i){super(t,e),this.contactPoint=i.clone()}}class f{constructor(t,e){super(t,e),this.contactNormal=new n,this.contactPoint=new n,this.penetration=0}}const m={};class g{constructor(t,e){this.lowerBound=t?t.clone():new n,this.upperBound=e?e.clone():new n}setFromPoints(t,e,i,s){const o=t[0];if(o){this.lowerBound.copy(o),this.upperBound.copy(o);for(let s=1;s<t.length;s++){const o=t[s];i&&(s.vmult(o,r.vector),o=r.vector,e&&o.vadd(e,o)),o.x>this.upperBound.x&&(this.upperBound.x=o.x),o.x<this.lowerBound.x&&(this.lowerBound.x=o.x),o.y>this.upperBound.y&&(this.upperBound.y=o.y),o.y<this.lowerBound.y&&(this.lowerBound.y=o.y),o.z>this.upperBound.z&&(this.upperBound.z=o.z),o.z<this.lowerBound.z&&(this.lowerBound.z=o.z)}return this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new g(this.lowerBound.clone(),this.upperBound.clone())}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,i=this.upperBound,s=t.lowerBound,o=t.upperBound;return(s.x<=i.x&&i.x<=o.x||e.x<=o.x&&o.x<=i.x)&&(s.y<=i.y&&i.y<=o.y||e.y<=o.y&&o.y<=i.y)&&(s.z<=i.z&&i.z<=o.z||e.z<=o.z&&o.z<=i.z)}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,i=this.upperBound;return e.x<=t.x&&t.x<=i.x&&e.y<=t.y&&t.y<=i.y&&e.z<=t.z&&t.z<=i.z}getCenter(t){const e=this.lowerBound,i=this.upperBound;return t.x=.5*(e.x+i.x),t.y=.5*(e.y+i.y),t.z=.5*(e.z+i.z),t}}const y={};class v{constructor(t,e){this.id=v.idCounter++,this.type=t,this.boundingSphereRadius=0,this.collisionResponse=e,this.collisionFilterGroup=1,this.collisionFilterMask=1,this.material=null,this.body=null}updateBoundingSphereRadius(){throw`method updateBoundingSphereRadius is not implemented in type ${this.type}`}volume(){throw`method volume is not implemented in type ${this.type}`}calculateLocalInertia(t,e){throw`method calculateLocalInertia is not implemented in type ${this.type}`}calculateWorldAABB(t,e,i,s){throw`method calculateWorldAABB is not implemented in type ${this.type}`}static idCounter=0,SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256}class C extends v{constructor(t){super({type:v.SPHERE}),this.radius=void 0!==t?t:1,this.radius<0&&(this.radius=1),this.updateBoundingSphereRadius()}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateLocalInertia(t,e){const i=2/5*t*this.radius*this.radius;return e.x=i,e.y=i,e.z=i,e}volume(){return 4/3*Math.PI*this.radius**3}calculateWorldAABB(t,e,i,s){const o=this.radius,n=i.x,r=i.y,h=i.z;s.lowerBound.set(n-o,r-o,h-o),s.upperBound.set(n+o,r+o,h+o)}}const w={};const b={};class S{constructor(t,e){this.elements=[],this.idPool=[],this.nextId=0,this.size=0}get(t){if(this.size<=0){const e=this.idPool.pop();return void 0!==e?e:this.nextId++}return this.size--,this.elements.pop()}release(t){this.idPool.push(t)}resize(t){const e=this.elements;for(;e.length<t;)e.push(this.get());for(;e.length>t;)this.release(e.pop());this.size=e.length}}const x={};class E{constructor(t={}){const{contactMaterial:e,contactPoint:i,normal:s}=t;this.id=E.idCounter++,this.bi=null,this.bj=null,this.ri=null,this.rj=null,this.si=null,this.sj=null,this.contactNormal=new n,this.penetration=0}static idCounter=0}const k={};class P extends v{constructor(){super({type:v.PLANE}),this.worldNormal=new n,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(t){const e=this.worldNormal;e.set(0,0,1),t.vmult(e,e),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(t,e){return e.set(0,0,0)}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,i,s){i.copy(s.lowerBound),i.copy(s.upperBound)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const M={};class T extends v{constructor(t){super({type:v.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,i=this.halfExtents.z,s=[new n(-t,-e,-i),new n(t,-e,-i),new n(t,e,-i),new n(-t,e,-i),new n(-t,-e,i),new n(t,-e,i),new n(t,e,i),new n(-t,e,i)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[6,5,1,2],[7,6,2,3],[4,7,3,0]],r=[new n(0,0,-1),new n(0,0,1),new n(0,-1,0),new n(0,1,0),new n(-1,0,0),new n(1,0,0)],h=new A(s,o,r);this.convexPolyhedronRepresentation=h,h.material=this.material}calculateLocalInertia(t,e){const i=this.halfExtents;return T.calculateInertia(i,t,e)}static calculateInertia(t,e,i){const s=t.x,o=t.y,n=t.z,r=1/12*e;return i.x=r*(2*o*2*o+2*n*2*n),i.y=r*(2*s*2*s+2*n*2*n),i.z=r*(2*o*2*o+2*s*2*s),i}getSideNormals(t,e){const i=t,s=this.halfExtents;if(i[0].set(1,0,0),i[1].set(0,1,0),i[2].set(0,0,1),i[3].set(-1,0,0),i[4].set(0,-1,0),i[5].set(0,0,-1),void 0!==e){for(let t=0;t!==i.length;t++)e.vmult(i[t],i[t]);return i}}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,i){const s=this.halfExtents,o=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let s=0;s<o.length;s++){r.v.set(o[s][0],o[s][1],o[s][2]),e.vmult(r.v,r.v),t.vadd(r.v,r.v),i(r.v.x,r.v.y,r.v.z)}}calculateWorldAABB(t,e,i,s){const o=this.halfExtents;r.v1.set(o.x,o.y,o.z),e.vmult(r.v1,r.v1),i.vadd(r.v1,s.upperBound),r.v2.set(-o.x,-o.y,-o.z),e.vmult(r.v2,r.v2),i.vadd(r.v2,s.lowerBound);const n=s.lowerBound,h=s.upperBound;if(n.x>h.x){const t=n.x;n.x=h.x,h.x=t}if(n.y>h.y){const t=n.y;n.y=h.y,h.y=t}if(n.z>h.z){const t=n.z;n.z=h.z,h.z=t}return}}r.v=new n,r.v1=new n,r.v2=new n;class A extends v{constructor(t=[],e=[],i=[]){super({type:v.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=e,this.faceNormals=i,this.uniqueEdges=null,this.uniqueAxes=null,this.computeEdges(),this.computeNormals(),this.updateBoundingSphereRadius()}computeEdges(){const t=this.faces,e=this.vertices,i={},s=[];for(let r=0;r!==t.length;r++){const h=t[r],a=h.length;for(let t=0;t!==a;t++){const r=h[t],l=(t+1)%a;let c,d;r<l?(c=r,d=l):(c=l,d=r);const u=`${c}-${d}`;i[u]||(i[u]=!0,s.push(new n(e[l].x-e[r].x,e[l].y-e[r].y,e[l].z-e[r].z)))}}this.uniqueEdges=s}computeNormals(){this.faceNormals.length=this.faces.length;const t=this.faceNormals;for(let e=0;e<this.faces.length;e++){const i=this.vertices[this.faces[e][0]],s=this.vertices[this.faces[e][1]],o=this.vertices[this.faces[e][2]];let r=t[e];r||(r=new n),s.vsub(i,r),o.vsub(i,r),r.cross(r,r),r.isZero()||r.normalize(),t[e]=r}return}static project(t,e,i,s){const o=t.vertices.length,r=e[0];let h;h=r.dot(i),s.min=h,s.max=h;for(let e=1;e<o;e++)h=t.vertices[e].dot(i),h>s.max&&(s.max=h),h<s.min&&(s.min=h)}calculateLocalInertia(t,e){const i=new n,s=new n;this.getAveragePointLocal(i),this.vertices.forEach((e=>{e.vsub(i,s),this.add(this.getTetrahedronVolume(s)*t/6*this.getInertiaTensor(s))}));const o=this.getTetrahedronVolume(i)*t/6;return e.add(this.getInertiaTensor(i),o.negate()),e}getTetrahedronVolume(t,e,i,s){const o=e.vsub(t),n=i.vsub(t),r=s.vsub(t);return Math.abs(o.dot(n.cross(r)))/6}getInertiaTensor(t,e,i,s,o){const n=t.x*t.x,r=t.y*t.y,h=t.z*t.z,a=t.x*t.y,l=t.x*t.z,c=t.y*t.z;o.x=e*(r+h),o.y=i*(n+h),o.z=s*(n+r),o.xy=-t*a,o.xz=-t*l,o.yz=-t*c}getAveragePointLocal(t){t=t||new n;const e=this.vertices;for(let i=0;i<e.length;i++)t.vadd(e[i],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const i=this.vertices.length,s=this.vertices;if(e){for(let i=0;i<s.length;i++){const o=s[i];t.vmult(o,o),e.vadd(o,o)}}else for(let i=0;i<s.length;i++){const e=s[i];t.vmult(e,e)}}clipAgainstHull(t,e,i,s,o,n,r,h,a){const l=new n,c=-1,d=o.vertices.length;let u=d,p=[];for(let t=0;t<d;t++)p.push(o.vertices[t]);for(let d=0;d<n.length&&u!==0;d++){const C=n[d];let w=0;l.copy(C);const b=Math.abs(l.dot(h));let S=C.dot(r),x=[];for(let t=0;t<u;t++){const e=p[t],i=l.dot(e)-S;if(i<=a){if(i<=0)x.push(e);else{const i=p[(t+u-1)%u];let s=l.dot(i)-S;if(s<=0){const s=e.vsub(i);let o=s.dot(l);if(Math.abs(o)>a){let o=Math.abs(s.dot(n[(d+1)%n.length])),r=Math.abs(s.dot(n[(d+2)%n.length]));if(o<b&&r<b)continue}const h=i/(i-s);s.scale(h,s),i.vadd(s,s),x.push(s)}else w++}}if(p=x,u=x.length,w>=p.length)return p.length}return i.length=0,t.length=0,e.length=0,p.forEach((s=>{i.push(s.x),t.push(s.y),e.push(s.z)})),p.length}findSeparatingAxis(t,e,i,s,o,n,r,h){let a=Number.MAX_VALUE;let l=this,c=t;const d=s.vsub(e,r);let u;if(d.lengthSquared()>.4*.4)for(let t=0;t<l.faces.length;t++){i.vmult(l.faceNormals[t],u),u=l.faceNormals[t];let e=l.testSepAxis(u,c,s,o);if(!1===e)return!1;e<a&&(a=e,n.copy(u))}if(o.w*o.w<1-.4*.4)for(let t=0;t<c.faces.length;t++){s.vmult(c.faceNormals[t],u),u=c.faceNormals[t];let e=l.testSepAxis(u,c,s,o);if(!1===e)return!1;e<a&&(a=e,n.copy(u))}for(let e=0;e<l.uniqueEdges.length;e++){i.vmult(l.uniqueEdges[e],u),u=l.uniqueEdges[e];for(let i=0;i<c.uniqueEdges.length;i++){o.vmult(c.uniqueEdges[i],r.vector);let d=u.cross(r.vector,r.vector);if(!d.isZero()){d.normalize();let i=l.testSepAxis(d,c,s,o);if(!1===i)return!1;i<a&&(a=i,n.copy(d))}}}return n.dot(d)>0&&n.negate(n),!0}testSepAxis(t,e,i,s){const o=this;let n=Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let e=0;e<o.vertices.length;e++){let i=t.dot(o.vertices[e]);i>r&&(r=i),i<n&&(n=i)}let h=Number.MAX_VALUE,a=-Number.MAX_VALUE;for(let o=0;o<e.vertices.length;o++){let n=t.dot(e.vertices[o]);n>a&&(a=n),n<h&&(h=n)}let l=i.dot(t)-s.dot(t);const c=n+l,d=r+l;return c>a||d<h?!1:Math.max(c-a,h-d)}calculateWorldAABB(t,e,i,s){let o,n,r,h,a,l,c=-Number.MAX_VALUE,d=-Number.MAX_VALUE,u=-Number.MAX_VALUE,p=Number.MAX_VALUE,f=Number.MAX_VALUE,m=Number.MAX_VALUE;const g=this.vertices.length,y=this.vertices;for(let s=0;s<g;s++){const g=y[s];e.vmult(g,w.v1),t.vadd(w.v1,w.v1),o=w.v1.x,n=w.v1.y,r=w.v1.z,(o>c||void 0===c)&&(c=o),(o<p||void 0===p)&&(p=o),(n>d||void 0===d)&&(d=n),(n<f||void 0===f)&&(f=n),(r>u||void 0===u)&&(u=r),(r<m||void 0===m)&&(m=r)}i.lowerBound.set(p,f,m),s.upperBound.set(c,d,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}updateBoundingSphereRadius(){let t=0;for(let e=0;e<this.vertices.length;e++){let i=this.vertices[e].lengthSquared();i>t&&(t=i)}this.boundingSphereRadius=Math.sqrt(t)}calculateLocalInertia(t,e){this.computeLocalAABB(w.aabbmin,w.aabbmax);const i=w.aabbmin.x,s=w.aabbmin.y,o=w.aabbmin.z,n=w.aabbmax.x,r=w.aabbmax.y,h=w.aabbmax.z;e.x=1/12*t*(2*s*2*s+2*o*2*o),e.y=1/12*t*(2*i*2*i+2*o*2*o),e.z=1/12*t*(2*s*2*s+2*i*2*i)}getPlaneConstantOfFace(t){const e=this.faces[t],i=this.faceNormals[t],s=this.vertices[e[0]];return-i.dot(s)}clipFaceAgainstHull(t,e,i,s){let o=-Number.MAX_VALUE;let r=null;const h=this.vertices.length;for(let e=0;e<h;e++){let i=this.vertices[e].dot(t);i>o&&(o=i,r=this.vertices[e])}const a=[],l=this.findClosestFace(t);this.getFaceVertices(l,a);let c=a[0];const d=c.vsub(r);let u=d.dot(t);for(let o=1;o<a.length;o++){let n=a[o],r=n.vsub(c);let h=t.dot(r),l=r.cross(d);if(h<0&&l.dot(s)>0)return!0;c=n,d=r}}findClosestFace(t){let e=-Number.MAX_VALUE;let i=null;const s=this.faces.length;for(let o=0;o<s;o++){let s=t.dot(this.faceNormals[o]);s>e&&(e=s,i=o)}return i}getFaceVertices(t,e){const i=this.faces[t];e.length=0;for(let t=0;t<i.length;t++)e.push(this.vertices[i[t]])}getEdgeVertices(t,e){const i=this.uniqueEdges[t];e[0]=this.vertices[i.a],e[1]=this.vertices[i.b]}computeLocalAABB(t,e){const i=this.vertices.length,s=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<s.length;i++){const o=s[i];o.x<t.x?t.x=o.x:o.x>e.x&&(e.x=o.x),o.y<t.y?t.y=o.y:o.y>e.y&&(e.y=o.y),o.z<t.z?t.z=o.z:o.z>e.z&&(e.z=o.z)}}w.v1=new n,w.v2=new n,w.aabbmin=new n,w.aabbmax=new n;class L extends v{constructor(t,e,i,s){const o={};if(super({type:v.HEIGHTFIELD}),this.data=t,this.maxValue=e,this.minValue=i,this.elementSize=s,this.cacheEnabled=!0,this.pillarConvex=new A,this.pillarOffset=new n,this.updateBoundingSphereRadius(),this._cachedPillars={},i>e)throw new Error("The minValue component must be smaller than the maxValue component.");this.update()}getij(t,e,i,s,o){const n=s.x/this.elementSize,r=s.y/this.elementSize;if((o[0]=Math.floor(n))<0?o[0]=0:o[0]>=t-1&&(o[0]=t-2),(o[1]=Math.floor(r))<0?o[1]=0:o[1]>=e-1&&(o[1]=e-2),n-o[0]>r-o[1])i[0]=o[0]+1,i[1]=o[1];else i[0]=o[0],i[1]=o[1]+1}getNormalAt(t,e,i,s){const o=new n,r=this.data;this.getij(t,e,i,s,b.getNormalAt_ij);const h=b.getNormalAt_ij[0],a=b.getNormalAt_ij[1],l=b.getNormalAt_edge;this.getij(t,e,l,s,b.getNormalAt_ij2);const c=b.getNormalAt_ij2[0],d=b.getNormalAt_ij2[1];let u=r[h][a];const p=r[i[0]][i[1]],f=r[l[0]][l[1]];if(c===h&&d===a)u=p,u>f?f=u:u=f,u=f;else u=f,u>p?p=u:u=p,u=p;const m=r[h+1][a],g=r[h][a+1],y=r[h+1][a+1];o.x=.5*(g-p+y-m),o.y=.5*(m-p+y-g),o.z=1}getAabb(){const t=this.elementSize*(this.data.length-1),e=this.elementSize*(this.data[0].length-1);return new g(new n(0,0,this.minValue),new n(t,e,this.maxValue))}getHeightAt(t,e,i){const s=this.data,o=this.elementSize,r=(s.length,s[0].length,Math.floor(t/o)),h=Math.floor(e/o);if(r<0||r>=s.length-1||h<0||h>=s[0].length-1)return 0;const a=(t%o)/o,l=(e%o)/o;let c,d;return a>l?(c=[r+1,h],d=[r,h+1]):(c=[r,h+1],d=[r+1,h]),(1-a-l)*s[r][h]+a*s[c[0]][c[1]]+l*s[d[0]][d[1]]}updateBoundingSphereRadius(){const t=(this.data.length-1)*this.elementSize,e=(this.data[0].length-1)*this.elementSize,i=.5*Math.sqrt(t*t+e*e);this.boundingSphereRadius=i}setHeightsFromAABB(t,e){const i=t.lowerBound,s=t.upperBound,o=Math.floor(s.x/this.elementSize)+1,r=Math.floor(s.y/this.elementSize)+1,h=this.data.length,a=this.data[0].length;for(let t=0;t<o;t++)for(let e=0;e<r;e++){const s=.5*(i.x+(t/o)*s.x),o=.5*(i.y+(e/r)*s.y),h=Math.floor(s/this.elementSize),l=Math.floor(o/this.elementSize);this.data[h][l]=(i.z+s.z+o.z)/3}}calculateLocalInertia(t,e){return e.set(0,0,0)}volume(){return Number.MAX_VALUE}clearCachedPillars(){this._cachedPillars={}}getPillar(t,e,i){this.cacheEnabled;const s=this.data,o=s.length,r=s[0].length,h=this.elementSize,a=s[t][e],l=s[t+1][e],c=s[t][e+1],d=s[t+1][e+1],u=this.pillarConvex,p=this.pillarOffset;u.vertices.length=8;for(let t=0;t<8;t++)u.vertices[t]||(u.vertices[t]=new n);u.faces.length=6;for(let t=0;t<6;t++)u.faces[t]||(u.faces[t]=[]),u.faces[t].length=4,u.faceNormals[t]||(u.faceNormals[t]=new n);const f=u.vertices;let m=Math.min(a,l,c,d),g=Math.max(a,l,c,d);f[0].set(-.5*h,-.5*h,m),f[1].set(.5*h,-.5*h,m),f[2].set(.5*h,.5*h,m),f[3].set(-.5*h,.5*h,m),f[4].set(-.5*h,-.5*h,g),f[5].set(.5*h,-.5*h,g),f[6].set(.5*h,.5*h,g),f[7].set(-.5*h,.5*h,g),u.faces[0][0]=0,u.faces[0][1]=1,u.faces[0][2]=2,u.faces[0][3]=3,u.faces[1][0]=7,u.faces[1][1]=6,u.faces[1][2]=5,u.faces[1][3]=4,u.faces[2][0]=0,u.faces[2][1]=1,u.faces[2][2]=5,u.faces[2][3]=4,u.faces[3][0]=1,u.faces[3][1]=2,u.faces[3][2]=6,u.faces[3][3]=5,u.faces[4][0]=2,u.faces[4][1]=3,u.faces[4][2]=7,u.faces[4][3]=6,u.faces[5][0]=3,u.faces[5][1]=0,u.faces[5][2]=4,u.faces[5][3]=7,u.computeNormals(),u.computeEdges(),u.updateBoundingSphereRadius(),p.set((t+.5)*h,(e+.5)*h,.5*(m+g))}calculateWorldAABB(t,e,i,s){const o=this.data,n=this.elementSize,r=o.length,h=o[0].length;s.lowerBound.set(0,0,this.minValue),s.upperBound.set((r-1)*n,(h-1)*n,this.maxValue)}}b.getNormalAt_ij=[0,0],b.getNormalAt_ij2=[0,0],b.getNormalAt_edge=new n;class _ extends v{constructor(t,e,i,s){const o=e,n=i,r=s;super({type:v.CYLINDER}),this.radiusTop=void 0!==o?o:1,this.radiusBottom=void 0!==n?n:1,this.height=void 0!==r?r:1,this.numSegments=void 0!==t?t:8;const h=[],[new A];this.convexPolyhedronRepresentation=h[1]}calculateLocalInertia(t,e){const i=this.radiusTop,s=this.radiusBottom,o=this.height,n=(i-s)/o;let r,h,a,l,c,d,u;const p=(i,s,o,n,r)=>{const h=Math.PI/4*Math.pow(o,4)*(r-n)*(.5*(r+n)+i/o*(Math.pow(r,2)+Math.pow(n,2))+3/8*Math.pow(i/o,2)*(Math.pow(r,3)+Math.pow(n,3)))-s/2};if(i.toPrecision(10)===s.toPrecision(10)){const t=p(0,o,i,-o/2,o/2);e.x=t,e.y=t;const s=Math.PI*Math.pow(i,2)*o,n=Math.pow(i,2)/2*s;e.z=n}else r=Math.PI*o/3*(i*i+i*s+s*s),c=1/10*r*(i*i+s*s+i*s)+1/20*r*o*o,l=1/20*r*(i*i+s*s+i*s)+1/80*r*o*o,h=(i+s)/2,a=1/2*Math.PI*o*(i*i*i*i+s*s*s*s+i*s*(i*i+s*s)+.5*i*i*s*s),d=1/2*Math.PI*o*o*(.5*(i*i+s*s)+i*s),u=1/2*Math.PI*o*(i*i+s*s),e.x=l,e.y=c,e.z=d}updateBoundingSphereRadius(){const t=this.height/2,e=Math.max(this.radiusTop,this.radiusBottom);this.boundingSphereRadius=Math.sqrt(e*e+t*t)}}class N extends v{constructor(){super({type:v.PARTICLE}),this.vertices=[]}}class D extends v{constructor(t=[],e={}){const{indices:i,vertices:s,normals:o,aabb:n}=e;super({type:v.COMPOUND});const r=this.childShapes=[],h=this.childOffsets=[],a=this.childOrientations=[],l=this.aabb=new g,c=this.aabbNeedsUpdate=!0;if(this.updateBoundingSphereRadius=this.updateBoundingSphereRadius.bind(this),s&&i){const t=i[0].length;i.forEach(((e,s)=>{const o=new A,n=[];e.forEach((t=>{const e=[vertices[t][0],vertices[t][1],vertices[t][2]];n.push(new n(...e))}));const r=[],h=[];for(let t=0;t<n.length/3;t++)r.push([3*t,3*t+1,3*t+2]);const a=[new n(0,0,1)];o.vertices=n,o.faces=r,o.faceNormals=a,o.computeNormals(),o.computeEdges(),o.updateBoundingSphereRadius(),this.addChild(o)}))}}}class F extends v{constructor(t,e){super({type:v.TRIMESH,collisionResponse:!1});const i=this.indices=t,s=this.vertices=e,o=this.normals=new Float32Array(i.length),n=this.aabb=new g,r=this.edges=null,h=this.edgeConvexDistances={};this.tree=new I({}),this.update()}}class I{constructor(t={}){const e=this.nodes=[];this.data=[]}get(t){}}const B={};class q{constructor(t,e,i,s,o,n,r){super(t,e),this.restitution=i,this.stiffness=s,this.relaxation=o,this.spr=new n,this.upperLimit=Number.MAX_VALUE,this.lowerLimit=-Number.MAX_VALUE,this.motor=new r,this.motor.enabled=!1,this.a=new n,this.b=new n}update(){const t=this.bi,e=this.bj,i=this.a,s=this.b;t.quaternion.vmult(i,i),e.quaternion.vmult(s,s);const o=this.getVelocityAlongAxis(),n=this.motor;if(n.enabled){const t=-o-n.targetVelocity;if(n.maxForce+t<0?this.motor.multiplier=n.maxForce+t:n.maxForce-t>0?this.motor.multiplier=n.maxForce-t:this.motor.multiplier=0)this.motor.enabled=!1}const r=this.spr;if(r.enabled){const t=-o;let e=this.stiffness*r.x-this.relaxation*o;const i=-t-this.upperLimit;i>0&&(e-=this.stiffness*i);const s=this.lowerLimit- -t;s>0&&(e+=this.stiffness*s),r.multiplier=e}}}class O{constructor(t,e,i,s){super(t,e),this.axisA=i,this.axisB=s,this.angle=0}update(){const t=this.bi,e=this.bj,i=this.axisA,s=this.axisB;super.update();const o=new n,r=new n;t.quaternion.vmult(i,o),e.quaternion.vmult(s,r);const h=t.quaternion.conjugate(),a=new h;e.quaternion.mult(h,a);const l=new n,c=new n;a.toEuler(l,"XYZ");const d=2*Math.asin(r.dot(l));this.angle=d}}const V=new n,z=new n;class W extends o{constructor(t,e,i){i=i||{};let s=i.maxForce;void 0===s&&(s=1e6),super(t,e,i);const o=new n,r=new n;i.pivotA?o.copy(i.pivotA):t.position.vadd(e.position,o).scale(.5,o),i.pivotB?r.copy(i.pivotB):e.position.vsub(t.position,r).scale(.5,r),this.pivotA=o,this.pivotB=r,this.equationX=new f(t,e),this.equationY=new f(t,e),this.equationZ=new f(t,e),this.equations.push(this.equationX,this.equationY,this.equationZ),this.equationX.minForce=-s,this.equationY.minForce=-s,this.equationZ.minForce=-s,this.equationX.maxForce=s,this.equationY.maxForce=s,this.equationZ.maxForce=s,this.equationX.ri.copy(o),this.equationY.ri.copy(o),this.equationZ.ri.copy(o),this.equationX.rj.copy(r),this.equationY.rj.copy(r),this.equationZ.rj.copy(r)}update(){const t=this.bodyA,e=this.bodyB,i=this.equationX,s=this.equationY,o=this.equationZ;t.quaternion.vmult(this.pivotA,V),e.quaternion.vmult(this.pivotB,z),i.contactNormal.set(1,0,0),s.contactNormal.set(0,1,0),o.contactNormal.set(0,0,1);const n=V;n.vadd(t.position,n),n.vsub(e.position,n),n.vsub(z,n),n.negate(n),i.contactPoint.copy(n),s.contactPoint.copy(n),o.contactPoint.copy(n)}}const j={};class G{constructor(t,e,i,s){this.id=G.idCounter++}}G.idCounter=0;class H extends W{constructor(t,e,i){i=i||{};const s=void 0===i.maxForce?1e6:i.maxForce,o=i.pivotA?i.pivotA.clone():new n,r=i.pivotB?i.pivotB.clone():new n;super(t,e,{pivotA:o,pivotB:r,maxForce:s});const h=this.axis=i.axis?i.axis.clone():new n(1,0,0);this.collideConnected=!1,this.angle=0;const a=this.equationX,l=this.equationY,c=this.equationZ,d=this.rotationalEquation=new O(t,e,i);this.equations.push(d),d.minForce=-s,d.maxForce=s,d.axisA.copy(h),d.axisA.normalize(),d.axisB.copy(h),d.axisB.normalize()}update(){const t=this.bodyA,e=this.bodyB;super.update(),t.quaternion.vmult(this.axis,this.rotationalEquation.axisA),e.quaternion.vmult(this.axis,this.rotationalEquation.axisB),this.rotationalEquation.update()}}const Z={};class R{constructor(t,e){this.id=R.idCounter++,this.minForce=void 0!==t?t:-1e6,this.maxForce=void 0!==e?e:1e6,this.bi=null,this.bj=null,this.si=null,this.sj=null,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new G,this.jacobianElementB=new G,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,3,1/60)}setSpookParams(t,e,i){const s=e,o=t,n=i;this.a=4/(n*(1+4*s)),this.b=4*s/(1+4*s),this.eps=4/(n*n*o*(1+4*s))}computeB(){const t=this.computeGq(),e=this.computeGdot();return this.computeGW()+.5*this.eps*(-this.computeGq()-.2*e-this.eps*t)}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj;return t.spatial.dot(i.position)+e.spatial.dot(s.position)}computeGdot(){const t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.velocity,n=s.velocity,r=i.angularVelocity,h=s.angularVelocity;return t.rotational.dot(r)+e.rotational.dot(h)+t.spatial.dot(o)+e.spatial.dot(n)}computeGW(){const t=this.bi,e=this.bj,i=this.jacobianElementA,s=this.jacobianElementB,o=t.invMass,n=e.invMass;let r=o+n,h=0;return t.invInertiaWorld&&(h+=i.rotational.dot(t.invInertiaWorld.vmult(i.rotational))),e.invInertiaWorld&&(h+=s.rotational.dot(e.invInertiaWorld.vmult(s.rotational))),r+h}computeGWlamda(){const t=this.bi,e=this.bj;let i=0;return t.invInertiaWorld&&(i+=t.invInertiaWorld.vmult(this.jacobianElementA.rotational).dot(this.jacobianElementA.rotational)),e.invInertiaWorld&&(i+=e.invInertiaWorld.vmult(this.jacobianElementB.rotational).dot(this.jacobianElementB.rotational)),i}addToWlamda(t){const e=this.jacobianElementA,i=this.jacobianElementB,s=this.bi,o=this.bj,n=s.invMass,r=o.invMass;t+=n+r,s.invInertiaWorld&&(t+=s.invInertiaWorld.vmult(e.rotational).dot(e.rotational)),o.invInertiaWorld&&(t+=o.invInertiaWorld.vmult(i.rotational).dot(i.rotational))}computeInvC(t){return 1/this.computeGW()}}class X{constructor(t,e,i){super(t,e),this.axis=i,this.maxForce=Number.MAX_VALUE}update(){const t=this.bi,e=this.bj,i=this.axis;super.update();const s=new n;s.copy(e.position),s.vadd(t.position,s),s.scale(.5,s);const o=this.a,r=this.b;t.quaternion.vmult(o,o),e.quaternion.vmult(r,r);const h=t.position.vadd(o),a=e.position.vadd(r);let l;i.normalize(),l=h.vsub(a),this.angle=l.dot(i),this.angle<this.lowerLimit?this.multiplier=this.stiffness*(this.lowerLimit-this.angle)-this.relaxation*this.getVelocityAlongAxis():this.angle>this.upperLimit?this.multiplier=this.stiffness*(this.upperLimit-this.angle)-this.relaxation*this.getVelocityAlongAxis():this.multiplier=0}}class Y{constructor(t,e){this.current=0}}class U{constructor(t){}}class Q extends o{constructor(t,e,i){i=i||{};const s=void 0===i.maxForce?1e6:i.maxForce,o=i.pivotA?i.pivotA.clone():t.position,r=i.pivotB?i.pivotB.clone():e.position;super(t,e,{maxForce:s,pivotA:o,pivotB:r,collideConnected:void 0===i.collideConnected||i.collideConnected});const h=this.axis=i.axis?i.axis.clone():new n(1,0,0);this.coneEquation=new G(t,e,{maxForce:s}),this.equations.push(this.coneEquation),t.quaternion.vmult(this.axis,this.coneEquation.axisA),e.quaternion.vmult(this.axis,this.coneEquation.axisB),this.angle=i.angle?i.angle:0,this.coneEquation.angle=this.angle}update(){const t=this.bodyA,e=this.bodyB,i=this.coneEquation;super.update(),t.quaternion.vmult(this.axis,i.axisA),e.quaternion.vmult(this.axis,i.axisB)}}class K extends o{constructor(t,e,i,s,o){o=o||{},super(t,e,o);const n=void 0===o.maxForce?1e6:o.maxForce,r=void 0===o.distance?Math.sqrt(Math.pow(s.x-i.x,2)+Math.pow(s.y-i.y,2)+Math.pow(s.z-i.z,2)):o.distance;r<0&&(console.warn("DistanceConstraint: distance cannot be negative."),r=0),this.localAnchorA=i?i.clone():new n,this.localAnchorB=s?s.clone():new n,this.distance=r;const h=this.distanceEquation=new p(t,e,r);this.equations.push(h),h.minForce=n,h.maxForce=n}update(){const t=this.bodyA,e=this.bodyB,i=this.distanceEquation,s=this.localAnchorA,o=this.localAnchorB;t.quaternion.vmult(s,i.ri),e.quaternion.vmult(o,i.rj),i.penetration=t.position.vadd(i.ri).distanceTo(e.position.vadd(i.rj))-this.distance}}class J{constructor(){this.bodies=[]}add(t){this.bodies.push(t)}remove(t){const e=this.bodies.indexOf(t);-1!==e&&this.bodies.splice(e,1)}getDistances(t,e){const i=this.bodies.length;for(let s=0;s<i;s++)for(let o=s+1;o<i;o++){const i=this.bodies[s],n=this.bodies[o];i.position.vsub(n.position,t),e.push(t.length())}}setOrientation(t){const e=this.bodies,i=e.length,s=new n(0,0,0);for(let t=0;t<i;t++)s.vadd(e[t].position,s);const o=1/i;s.scale(o,s);const r=new n,h=new n,a=new l;for(let o=0;o<i;o++){const i=e[o];i.position.vsub(s,r),h.set(t.w*t.w-t.x*t.x-t.y*t.y+t.z*t.z,2*(t.y*t.z+t.w*t.x),2*(t.z*t.x-t.w*t.y)),a.setRotationFromQuaternion(t),i.position=a.vmult(r)}}}const $={};class tt{constructor(t){this.id=tt.idCounter++,this.body=t,this.next=null,this.previous=null}static idCounter=0}class et{constructor(){this.head=null,this.tail=null}add(t){null===this.head?this.head=t:this.tail.next=t,t.previous=this.tail,t.next=null,this.tail=t}remove(t){null===t.previous?this.head=t.next:t.previous.next=t.next,null===t.next?this.tail=t.previous:t.next.previous=t.previous,t.next=t.previous=null}find(t){let e;for(e=this.head;e!==null&&e.body!==t;e=e.next);return e}insertBefore(t,e){e.previous=t.previous,e.next=t,null===t.previous?this.head=e:t.previous.next=e,t.previous=e}get(t){let e,i;for(e=this.head,i=0;e!==null&&i<t;e=e.next,i++);return e}clear(){let t=this.head;for(;null!==t;){const e=t;t=t.next,e.next=e.previous=null}}}const it={};class st{constructor(){this.nodes=[]}insert(t,e,i=0){const s=this.nodes[i];if(!s||t.aabb.contains(s.aabb))if(s&&s.children.length){let t=!1;for(let o=0;o<s.children.length;o++){const n=s.children[o];if(e.aabb.overlaps(n.aabb)){t=!0,this.insert(e,n.aabb,n.id)}}}else this.nodes.push(t)}get(t){}}class ot{constructor(t,e,i={}){this.dt=null,this.world=null,this.iterations=i.iterations?i.iterations:10,this.tolerance=i.tolerance?i.tolerance:1e-7,this.k=new l,this.d=new l,this.zeroreduced=new l,this.equations=[],this.invC=new Y,this.preSolve=i.preSolve?i.preSolve:null,this.postSolve=i.postSolve?i.postSolve:null,this.body_i=t,this.body_j=e,this.useSplit=i.useSplit?i.useSplit:!1}solve(t,e){let i,s=this.iterations,o=this.tolerance*this.tolerance,n=this.equations,r=n.length,h=e.bodies,a=h.length,l=t;if(r>0)for(let t=0;t<a;t++){h[t].updateSolveCounts()}if(0!==r){for(let t=0;t<a;t++){const e=h[t];e.updateInvMassLattice()}}const c=this.invC,d=this.k,u=this.d,p=this.zeroreduced;for(c.resize(r),d.resize(r,r),u.resize(r,r),p.resize(r,r),this.d.setZero(),this.k.setZero(),this.zeroreduced.setZero(),i=0;i<r;i++){const t=n[i];t.updateSpookParams(e.stepnumber),d.set(i,i,t.computeGW()),p.set(i,i,t.computeGW())}let f,m,g,y,v,C,w,b,S,x,E,k,P,M,T,A,L,_,N,D,F,I,B,q,O;if(this.useSplit)for(d.set(0,1,n[0].computeGiMf()),u.set(0,1,n[0].computeGiMGt()),d.set(1,0,n[1].computeGiMf()),u.set(1,0,n[1].computeGiMGt()),i=2;i<r;i++)d.set(i,i,n[i].computeGW()),p.set(i,i,n[i].computeGW());for(let t=0;t<r;t++){const e=n[t];if(e.enabled){const i=e.bi,s=e.bj;i.isSleeping()&&i.awaken(),s.isSleeping()&&s.awaken(),this.preSolve&&this.preSolve(),i.updateSolveCounts()}}let V,z;for(let t=0;t<s;t++){z=0;for(let e=0;e<r;e++){const i=n[e];if(i.enabled){V=i.computeB();const s=c.get(e);let o=-V-s;const h=i.minForce,a=i.maxForce;o>h&&o<a?o=0:o<h?o=h-o:o>a&&(o=a-o);const l=o-s;i.multiplier+=l,c.set(e,i.multiplier),z+=Math.abs(l),i.addToWlambda(l)}}if(z*z<o)break}for(i=0;i<a;i++){h[i].updatevlambda()}if(r>0){const t=new Float32Array(r);for(i=0;i<r;i++)t[i]=n[i].computeB();for(let e=0;e<s&&z*z>o;e++){z=0;for(i=0;i<r;i++){const e=n[i];V=t[i]+e.computeGWlamda();const s=-V;e.multiplier=Math.min(e.maxForce,Math.max(e.minForce,s)),z+=Math.abs(s)}if(z*z<o)break}for(i=0;i<a;i++){h[i].applyForce(t)}for(i=0;i<r;i++){const e=n[i];e.multiplier=t[i],this.postSolve&&this.postSolve()}}}return s}}const nt={};class rt extends ot{constructor(t,e,i,s){s=s||{};const o=new C(i);super(t,o,s),o.collisionFilterGroup=0,o.collisionFilterMask=0,o.body=o;const n=this.equations[0];n.contactNormal.set(1,0,0),n.penetration=-i,n.minForce=-s.maxForce,n.maxForce=s.maxForce}getSide(){return this.equations[0].contactNormal.dot(this.body_i.position)-this.body_j.position.dot(this.body_i.position)}}const ht={};class at{constructor(t,e,i){i=i||{};const s=new n,o=new n,r=new n;this.axis1=void 0!==i.axis1?i.axis1.clone():new n(1,0,0),this.axis2=void 0!==i.axis2?i.axis2.clone():new n(0,1,0),this.motor1=new G(t,e,{maxForce:i.maxForce}),this.motor2=new G(t,e,{maxForce:i.maxForce}),this.motor1.axis=this.axis1,this.motor2.axis=this.axis2,this.restitution=void 0!==i.restitution?i.restitution:0,this.stiffness=void 0!==i.stiffness?i.stiffness:1e6,this.relaxation=void 0!==i.relaxation?i.relaxation:3,o.constructor(t,e,{maxForce:i.maxForce}),r.constructor(t,e,{maxForce:i.maxForce}),s.constructor(t,e,{maxForce:i.maxForce}),this.equations=[this.motor1,this.motor2,o,r,s]}update(){const t=this.equations[0],e=this.equations[1],i=this.equations[2],s=this.equations[3],o=this.equations[4];i.update(),s.update(),o.update(),t.update(),e.update()}}class lt{constructor(){this.contactmaterials=[],this.frictionEquationStiffness=1e7,this.frictionEquationRelaxation=3,this.restitution=0,this.stiffness=1e7,this.relaxation=3}add(t){this.contactmaterials.push(t)}get(t,e){for(let i=0;i<this.contactmaterials.length;i++){const s=this.contactmaterials[i];if(s.materials.includes(t)&&s.materials.includes(e))return s}return null}}class ct{constructor(){this.contactMaterialTable=new lt,this.defaultContactMaterial=new s,this.result=[],this.frictionResult=[]}collisionMatrix(t,e,i){let s;const o=t.length,n=new Array(o);for(s=0;s<o;s++)n[s]=[];for(s=0;s<o;s++){const r=t[s];for(let h=0;h<o;h++){const o=t[h];r.id<o.id&&(r.aabb.overlaps(o.aabb)&&!n[s][h]&&(n[s][h]=n[h][s]=!0,e.push(r),i.push(o)))}}return this}}class dt{constructor(t,e,i){this.contactPointB=new n,this.contactPointA=new n,this.distance=0,this.id=void 0!==i?i:-1}create(t,e,i,s){this.contactPointA.copy(t),this.contactPointB.copy(e),this.distance=s}destroy(){this.id=-1}}class ut{constructor(t,e,i,s,o){this.minForce=void 0!==o?o:-Number.MAX_VALUE,this.maxForce=void 0!==s?s:Number.MAX_VALUE,this.ni=new n,this.ri=new n,this.rj=new n,this.shadowMultiplier=0,this.bias=0,this.gmult=new n,this.numIterations=void 0!==i?i:5,this.used=0,this.useStates=new Float32Array(i),this.multiplier=new Float32Array(i),this.relVel=new Float32Array(i),this.relForce=new Float32Array(i),this.bodies=[]}update(){this.bodies[0],this.bodies[1]}}const pt={};var ft=["x","y","z"];const mt={};class gt extends R{constructor(t,e,i){i=void 0!==i?i:1e6,super(-i,i),this.type=R.CONTACT,this.contactPoint=new n,this.penetration=new n,this.contactNormal=new n,this.restitution=0,this.ri=new n,this.rj=new n,this.ni=new n,this.rixn=new n,this.rjxn=new n}computeB(t,e,i){const s=this.a,o=this.b,n=this.bi,r=this.bj,h=this.ri,a=this.rj,l=n.velocity,c=n.angularVelocity,d=r.velocity,u=r.angularVelocity,p=this.contactNormal,f=this.contactPoint,m=this.penetration,g=n.invMass,y=r.invMass,v=this.restitution,C=p.dot(l.vsub(d,b.v3)),w=this.computeGW();let x;if(v>0){const t=v*C;x=v*p.dot(u.cross(a,b.v1).vadd(d,b.v1).vsub(c.cross(h,b.v2).vadd(l,b.v2),b.v2))}return-t*p.dot(l.vsub(d,b.v3))-.5*o*(C-x)-s*m-.2*p.dot(n.force.scale(g).vsub(r.force.scale(y)))}getImpactVelocityAlongNormal(){const t=this.bi,e=this.bj,i=this.ri,s=this.rj;return this.ni.dot(t.getVelocityAtWorldPoint(t.position.vadd(i),b.v1).vsub(e.getVelocityAtWorldPoint(e.position.vadd(s),b.v2),b.v3))}computeReciproqualMass(t,e,i){const s=new n,o=new n;return this.ni.dot(s.vsub(o))}getVelocityAlongNormal(){const t=this.bi,e=this.bj,i=this.ri,s=this.rj;return this.ni.dot(t.velocity.vadd(i.cross(t.angularVelocity))).vsub(e.velocity.vadd(s.cross(e.angularVelocity)))}applyImpulse(t,e,i){const s=this.bi,o=this.bj,n=this.ni;let r=t*n;s.velocity.vadd(r.scale(s.invMass),s.velocity),o.velocity.vsub(r.scale(o.invMass),o.velocity);const h=new n;n.cross(this.ri,h),s.angularVelocity.vadd(s.invInertiaWorld.vmult(h.scale(t)),s.angularVelocity),n.cross(this.rj,h),o.angularVelocity.vsub(o.invInertiaWorld.vmult(h.scale(t)),o.angularVelocity)}}b.v1=new n,b.v2=new n,b.v3=new n;class yt extends R{constructor(t,e,i,s,o){o=o||{},super(-i,i),this.type=R.FRICTION,this.contactPoint=new n,this.friction=s,this.contactEquations=[],this.rows=3,this.numContacts=1,this.slip=o.slip,this.t=new n,this.ri=new n,this.rj=new n,this.rixn=new n,this.rjxn=new n,this.w=new Y}setSlipForce(t){this.slipForce=t}getSlipForce(){return this.slipForce}computeB(t,e,i){const s=this.a,o=this.b,n=this.bi,r=this.bj,h=this.ri,a=this.rj,l=n.velocity,c=n.angularVelocity,d=r.velocity,u=r.angularVelocity,p=this.t,f=this.slipForce,m=this.computeGW();return-this.b*p.dot(l.vsub(d))-this.a*(c.dot(h)-u.dot(a))}}}const vt={};class Ct{constructor(t,e,i,s){this.id=s||-1,this.normal=new n,this.ownBody=t,this.otherBody=e,this.distance=i||-1}}class wt{constructor(){this.idCounter=0,this.requests=[],this.probedFaces=new Int8Array,this.id=0}get Id(){return this.id}create(t,e){this.requests.push({body:t,result:e})}probe(t,e,i,s,o){const n=this.requests,r=n.length;for(let h=0;h<r;h++){const r=n[h],a=r.body,l=r.result;if(l.id>this.id&&l.distance<s)return}this.id=this.idCounter++,l.v1.copy(e.position),e.quaternion.vmult(e.aabb.upperBound,l.v2),l.v1.vadd(l.v2,l.v2);const h=l.v2,a=new n,l=new n;let c;const d=t.faceNormals.length,u=[];for(let t=0;t<d;t++)u.push(!1);const p=-1;for(let e=0;e<t.faces.length;e++){const n=t.faces[e];if(u[e]){const r=t.faceNormals[e];t.getPlaneConstantOfFace(e);if(h.dot(r)>.1){u[e]=!1;continue}const d=new n;c=this.pointInTriangle(h,t.vertices[n[0]],t.vertices[n[1]],t.vertices[n[2]]);const p=new Ct(i,o,h.distanceTo(c),this.id);s.push(p)}}}}class bt{constructor(){this.wakeUpTime=0,this.allowSleep=!0,this.sleepSpeedLimit=.1,this.sleepTimeLimit=1,this.sleepState=bt.AWAKE,this.timeLastGoingToSleep=-1,this.bodies=[]}goToSleep(t){const e=t.bodies.length;for(let i=0;i<e;i++){const e=t.bodies[i];e.sleep()}}wakeUp(t){for(let e=0;e<t.bodies.length;e++){const i=t.bodies[e];i.wakeUp()}this.wakeUpTime=t.time}update(t){this.wakeUpTime>t.time;for(let e=0;e<t.bodies.length;e++){const i=t.bodies[e];i.updateSleepState(t)}}}bt.AWAKE=0,bt.SLEEPY=1,bt.SLEEPING=2;class St extends at{constructor(t,e,i){const s=(i=i||{}).pivotA?i.pivotA.clone():t.position,o=i.pivotB?i.pivotB.clone():e.position;super(t,e,{maxForce:i.maxForce,pivotA:s,pivotB:o,axis1:i.axis1,axis2:i.axis2}),this.motor=new H(t,e,i)}}class xt{constructor(t,e,i,s,o){o=o||{},this.angle=o.angle?o.angle.clone():new n;const r=new H(t,e,o);this.equations=[r]}}class Et extends at{constructor(t,e,i){i=i||{};const s=i.pivotA?i.pivotA.clone():t.position,o=i.pivotB?i.pivotB.clone():e.position;super(t,e,i),this.motor1=new G(t,e,{maxForce:i.maxForce})}}class kt{constructor(t){}}var Pt={};const Mt={};var Tt={};class At{constructor(t,e){this.id=At.idCounter++,this.type=e,this.preStep=null,this.postStep=null,this.body=t,this.body.preStep=this.preStep,this.body.postStep=this.postStep}static idCounter=0,POST_STEP:1,PRE_STEP:2}class Lt extends At{constructor(t,e){e=e||{};const i=new n,s=e.localPoint?e.localPoint:new n;super(t,At.POST_STEP),this.force=i.copy(e.force),this.localPoint=s.copy(e.localPoint),this.point=new n,this.apply=()=>{const t=new n;this.body.quaternion.vmult(this.localPoint,this.point),this.body.applyForce(this.force,this.point)}}}class _t extends At{constructor(t,e){e=e||{},super(t,At.POST_STEP),this.localPoint=e.localPoint?e.localPoint.clone():new n,this.impulse=e.impulse?e.impulse.clone():new n,this.point=new n,this.apply=()=>{const t=new n;this.body.quaternion.vmult(this.localPoint,this.point),this.body.applyImpulse(this.impulse,this.point)}}}class Nt extends At{constructor(t,e){e=e||{},super(t,At.POST_STEP),this.localTorque=e.localTorque?e.localTorque.clone():new n,this.torque=this.localTorque.clone(),this.apply=()=>{this.body.quaternion.vmult(this.localTorque,this.torque),this.body.torque.vadd(this.torque,this.body.torque)}}}class Dt extends At{constructor(t,e){e=e||{},super(t,At.POST_STEP),this.localTorque=e.localTorque?e.localTorque.clone():new n,this.torque=this.localTorque.clone(),this.apply=()=>{this.body.quaternion.vmult(this.localTorque,this.torque),this.body.angularVelocity.vadd(this.body.invInertia.vmult(this.torque),this.body.angularVelocity)}}}class Ft extends At{constructor(t,e,i){super(t,At.PRE_STEP),this.spring=new G(t,e,{restLength:i.restLength,stiffness:i.stiffness,damping:i.damping,localAnchorA:i.localAnchorA,localAnchorB:i.localAnchorB})}}const It={};class Bt extends At{constructor(t,e){e=e||{};const i=new n,s=e.localAxis?e.localAxis:new n(0,0,1);super(t,At.POST_STEP),this.axis=i.copy(s),this.maxForce=void 0!==e.maxForce?e.maxForce:100,this.apply=()=>{let t=this.body.vlambda.dot(this.axis);t>0&&(t=0),this.body.vlambda.vadd(this.axis.scale(-t),this.body.vlambda)}}}class qt extends At{constructor(t,e){e=e||{};const i=new n,s=e.localAxis?e.localAxis:new n(0,0,1);super(t,At.POST_STEP),this.axis=i.copy(s),this.maxForce=void 0!==e.maxForce?e.maxForce:100,this.apply=()=>{let t=this.body.wlambda.dot(this.axis);t>0&&(t=0),this.body.wlambda.vadd(this.axis.scale(-t),this.body.wlambda)}}}class Ot{constructor(t,e){this.x=t.clone(),this.y=e.clone(),this.z=new n,this.x.cross(this.y,this.z)}toLocal(t){return new n(t.dot(this.x),t.dot(this.y),t.dot(this.z))}toWorld(t){return this.x.scale(t.x).vadd(this.y.scale(t.y)).vadd(this.z.scale(t.z))}}class Vt{constructor(t,e){e=e||{};const i=new n,s=e.localForward?e.localForward.clone():new n(0,0,1),o=e.localUp?e.localUp.clone():new n(0,1,0);this.body=t,this.frame=new Ot(s,o),e.worldForward&&(this.frame.x=e.worldForward.clone()),e.worldUp&&(this.frame.y=e.worldUp.clone()),this.frame.z.copy(this.frame.x.cross(this.frame.y)),this.maxTorque=void 0!==e.maxTorque?e.maxTorque:1/0}update(){const t=this.body.quaternion.vmult(this.frame.x),e=this.body.quaternion.vmult(this.frame.y),i=t.cross(this.frame.x).vadd(e.cross(this.frame.y));i.length()>this.maxTorque&&i.scale(this.maxTorque/i.length(),i),this.body.torque.vadd(i,this.body.torque)}}class zt extends At{constructor(t,e){e=e||{},super(t,At.POST_STEP),this.gravity=e.gravity?e.gravity.clone():new n(0,0,-10),this.apply=()=>{this.body.velocity.vadd(this.gravity.scale(this.body.world.dt),this.body.velocity)}}}class Wt extends At{constructor(t,e){e=e||{};const i=new n,s=e.point?e.point:new n;super(t,At.POST_STEP),this.point=i.copy(s),this.apply=()=>{this.body.velocity.vsub(this.body.getVelocityAtWorldPoint(this.point),this.body.velocity)}}}class jt{constructor(t){this.id=jt.idCounter++,this.body=t,this.velocity=new n,this.force=new n,this.position=new n,this.invMass=0,this.invInertia=new n,this.invInertiaWorld=new l,this.fixedRotation=!1,this.useGravity=!0,this.vlambda=new n,this.wlambda=new n,this.linearDamping=.01,this.angularDamping=.01,this.sleepState=0,this.world=null,this.events=new e,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new n,this.invInertia=new n,this.invMass=0,this.mass=0,this.type=t.mass<=0?jt.STATIC:jt.DYNAMIC,this.allowSleep=!0,this.sleepState=0,this.sleepSpeedLimit=.1,this.sleepTimeLimit=1,this.timeLastGoingToSleep=0,this.collisionFilterGroup=1,this.collisionFilterMask=-1,this.fixedRotation=!1,this.angularDamping=.01,this.linearDamping=.01,this.velocity=new n,this.angularVelocity=new n,this.force=new n,this.torque=new n,this.vlambda=new n,this.wlambda=new n,this.invInertiaWorld=new l,this.position=t.position?t.position.clone():new n,this.quaternion=t.quaternion?t.quaternion.clone():new h,this.shapes=t.shapes?t.shapes.map((t=>t.clone())):[],this.invInertia=t.invInertia?t.invInertia.clone():new n,this.inertia=t.inertia?t.inertia.clone():new n,this.mass=t.mass||0,this.invMass=this.mass>0?1/this.mass:0,this.updateMassProperties()}static idCounter=0,AWAKE:0,SLEEPY:1,SLEEPING:2,STATIC:1,DYNAMIC:2,KINEMATIC:4,COLLIDE_EVENT_NAME:"collide"dispatchEvent(t){"string"==typeof t&&(t={type:t}),this.events.has(t.type)&&this.events.emit(t)}wakeUp(){this.sleepState===jt.SLEEPING&&(this.sleepState=jt.AWAKE,this.timeLastGoingToSleep=-1,this.events.emit(jt.wakeupEvent))}sleep(){this.sleepState=jt.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.timeLastGoingToSleep=this.world.time,this.events.emit(jt.sleepEvent)}goToSleep(){this.sleepState=jt.SLEEPING}updateSleepState(t){if(this.allowSleep){const e=this.velocity.length(),i=this.angularVelocity.length(),s=Math.pow(this.sleepSpeedLimit,2);e*e+i*i>s?(this.sleepState=jt.AWAKE,this.timeLastGoingToSleep=-1):this.sleepState=jt.SLEEPY,this.timeLastGoingToSleep=-1,this.sleepState===jt.SLEEPY&&t.time-this.timeLastGoingToSleep>this.sleepTimeLimit&&(this.sleepState=jt.SLEEPING,this.events.emit("sleep"))}}isSleeping(){return this.sleepState===jt.SLEEPING}isAwake(){return this.sleepState===jt.AWAKE}isSleepy(){return this.sleepState===jt.SLEEPY}getVelocityAtWorldPoint(t,e){const i=t.vsub(this.position);return e.copy(this.velocity),this.angularVelocity.cross(i,i),e.vadd(i,e),e}vectorToLocalFrame(t,e){e=e||new n,t.vsub(this.position,e),this.quaternion.conjugate(b.qt).vmult(e,e)}vectorToWorldFrame(t,e){return e=e||new n,this.quaternion.vmult(t,e),e}addShape(t,e,i){this.shapes.push(t),this.shapeOffsets.push(e||new n),this.shapeOrientations.push(i||new h),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets;this.boundingRadius=0;for(let i=0;i<t.length;i++){const s=t[i];s.updateBoundingSphereRadius();const o=s.boundingSphereRadius;let n=e[i].length();let r=o+n;r>this.boundingRadius&&(this.boundingRadius=r)}}updateAABB(){const t=this.shapes,e=this.shapeOffsets,i=this.shapeOrientations,s=this.aabb,o=new g;for(let r=0;r<t.length;r++){const h=t[r],a=e[r],l=i[r];h.calculateWorldAABB(this.position.vadd(a),this.quaternion.mult(l),o.lowerBound,o.upperBound),0===r?s.copy(o):s.extend(o)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(t||(e.x||e.y||e.z))e.x||e.y||e.z?this.invInertiaWorld.setRotationFromQuaternion(this.quaternion).scale(e):this.invInertiaWorld.identity();else this.invInertiaWorld.setZero()}applyForce(t,e){if(this.type!==jt.DYNAMIC)return;e=e||new n;const i=e.vsub(this.position);this.force.vadd(t,this.force),this.torque.vadd(i.cross(t),this.torque)}applyImpulse(t,e){if(this.type!==jt.DYNAMIC)return;const i=e||new n,s=i.vsub(this.position);this.velocity.vadd(t.scale(this.invMass),this.velocity),this.angularVelocity.vadd(s.cross(t).scale(this.invInertia),this.angularVelocity)}updateMassProperties(){this.invMass=this.mass>0?1/this.mass:0;const t=new l;this.inertia.set(0,0,0),this.invInertia.set(0,0,0);for(let e=0;e<this.shapes.length;e++){const i=this.shapes[e],s=this.shapeOffsets[e];i.calculateLocalInertia(this.mass,t),this.inertia.x+=t.x,this.inertia.y+=t.y,this.inertia.z+=t.z}this.inertia.x>0&&(this.invInertia.x=1/this.inertia.x),this.inertia.y>0&&(this.invInertia.y=1/this.inertia.y),this.inertia.z>0&&(this.invInertia.z=1/this.inertia.z),this.updateInertiaWorld(!0)}}b.qt=new h,jt.wakeupEvent={type:"wakeup"},jt.sleepEvent={type:"sleep"};class Gt{constructor(t={}){Object.assign(this,t),this.time=0,this.stepnumber=0,this.dt=-1,this.gravity=new n,this.broadphase=null,this.bodies=[],this.hasTrigger=null,this.constraints=[],this.narrowphase=new ct,this.solver=new ot,this.bodiesToBeRemoved=[],this.materials=[],this.contactmaterials=[],this.quatNormalizeSkip=0,this.quatNormalizeFast=!1,this.subsystems=[],this.collisionMatrix=new ct,this.collisionMatrixPrevious=new ct,this.allowSleep=!1,this.sleepManager=new bt,this.accumulator=0,this.contacts=[],this.frictionEquations=[],this.broadphase=t.broadphase||new e,this.solver=t.solver||new ot,this.gravity=t.gravity||new n,this.allowSleep=t.allowSleep||!1}addBody(t){-1===this.bodies.indexOf(t)&&(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion),this.broadphase.add(t))}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const e=this.constraints.indexOf(t);-1!==e&&this.constraints.splice(e,1)}removeBody(t){t.world=null;const e=this.bodies.indexOf(t);-1!==e&&(this.bodies.splice(e,1),this.broadphase.remove(t));for(let i=0;i<this.bodies.length;i++)this.bodies[i].index=i}getBodyById(t){for(const e of this.bodies)if(e.id===t)return e;return null}getContactMaterial(t,e){return this.narrowphase.contactMaterialTable.get(t,e)}addContactMaterial(t){this.narrowphase.contactMaterialTable.add(t)}addMaterial(t){this.materials.push(t)}internalStep(t){this.dt=t;const e=this.constraints,i=this.bodies;let s,o,n,r,h,a,l,c,d,u,p,f,m,g,y;const v=i.length;for(s=0;s<v;s++){i[s].updateMassProperties()}for(s=0;s<v;s++){const t=i[s];t.preStep&&t.preStep(),t.integrate(t)}this.clearForces(),this.broadphase.collisionPairs(this,this.pairs1,this.pairs2);const C=e.length;for(s=0;s<C;s++)e[s].update();const w=this.narrowphase,b=this.contacts.length;for(s=0;s<b;s++)w.contactPool.release(this.contacts.pop());const S=this.frictionEquations.length;for(s=0;s<S;s++)w.frictionEquationPool.release(this.frictionEquations.pop());const x=this.pairs1,E=this.pairs2,k=x.length,P=this.narrowphase.result,M=this.narrowphase.frictionResult;for(this.numcontacts=0,s=0;s<k;s++)w.getContacts(x[s],E[s],this,P,null,M,null);const T=P.length;if(T>b)throw new Error("CANNON.World.contacts seems to have leaked contacts.");const A=M.length;if(A>S)throw new Error("CANNON.World.frictionEquations seems to have leaked friction equations.");for(s=0;s<T;s++)this.contacts.push(P[s]);for(s=0;s<A;s++)this.frictionEquations.push(M[s]);this.allowSleep&&this.sleepManager.update(this);const L=this.solver;L.equations.length=0,L.equations.push.apply(L.equations,this.contacts),L.equations.push.apply(L.equations,this.frictionEquations),L.equations.push.apply(L.equations,e);for(s=0;s<v;s++){i[s].updateSolveCounts()}L.solve(t,this);for(s=0;s<v;s++){i[s].postStep&&i[s].postStep()}}step(t,e,i){i=i||10,e=e||0,e>0?(this.accumulator+=e,this.step(t)):(this.accumulator+=t,this.internalStep(t));let s=0;for(;this.accumulator>=t&&s<i;)this.internalStep(t),this.accumulator-=t,s++}clearForces(){const t=this.bodies;for(let e=0;e<t.length;e++){const i=t[e];i.force.set(0,0,0),i.torque.set(0,0,0)}}}Object.assign(e,i),t.AABB=g,t.ArrayCollisionMatrix=ct,t.BODY_SLEEP_STATES=bt,t.BODY_TYPES=jt,t.Body=jt,t.Box=T,t.Broadphase=class{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,i){throw new Error("collisionPairs not implemented for this broadphase class.")}needBroadphaseCollision(t,e){return!(!t.collisionFilterMask||!e.collisionFilterGroup||!e.collisionFilterMask||!t.collisionFilterGroup)||!!(t.collisionFilterGroup&e.collisionFilterMask&&e.collisionFilterGroup&t.collisionFilterMask)}intersectionTest(t,e,i,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,i,s):this.doBoundingSphereBroadphase(t,e,i,s)}doBoundingSphereBroadphase(t,e,i,s){const o=t.boundingRadius+e.boundingRadius;t.position.vsub(e.position,r.distsq)>o*o&&(i.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,i,s){t.aabbNeedsUpdate&&(t.computeAABB(),e.aabbNeedsUpdate&&e.computeAABB()),t.aabb.overlaps(e.aabb)&&(i.push(t),s.push(e))}makePairsUnique(t,e){const i=[],s={},o=t.length;for(let n=0;n<o;n++){const o=t[n],r=e[n],h=`${Math.min(o.id,r.id)}-${Math.max(o.id,r.id)}`;s[h]||(i.push(o,r),s[h]=!0)}t.length=0,e.length=0;for(let i=0;i<t.length;i++)t[i]=i[2*i],e[i]=i[2*i+1]}setWorld(t){this.world=t}},t.COLLISION_TYPES=v,t.ConeTwistConstraint=Q,t.Constraint=o,t.ContactEquation=f,t.ContactMaterial=o,t.ConvexPolyhedron=A,t.Cylinder=_,t.DistanceConstraint=K,t.Equation=R,t.Event=e,t.EventTarget=e,t.FrictionEquation=p,t.GSSolver=ot,t.GridBroadphase=class extends e{constructor(t,e,i,s,o){super(),this.nx=i||10,this.ny=s||10,this.nz=o||10,this.aabbMin=t||new n(100,100,100),this.aabbMax=e||new n(-100,-100,-100);const r=this.nx*this.ny*this.nz;r<=0&&console.warn("GridBroadphase: The number of bins must be > 0."),this.bins=[],this.binLengths=[],this.bins.length=r,this.binLengths.length=r;for(let t=0;t<r;t++)this.bins[t]=[],this.binLengths[t]=0}collisionPairs(t,e,i){const s=t.bodies,o=s.length,r=this.bins,h=this.aabbMin,a=this.aabbMax,l=this.nx,c=this.ny,d=this.nz,u=l/ (a.x -h.x),p=c/(a.y-h.y),f=d/(a.z-h.z),m=Math.min;for(let t=0;t<o;t++){const e=s[t],i=e.aabb,o=m(l-1,Math.floor(u*(i.lowerBound.x-h.x))),n=m(c-1,Math.floor(p*(i.lowerBound.y-h.y))),r=m(d-1,Math.floor(f*(i.lowerBound.z-h.z))),g=m(l-1,Math.floor(u*(i.upperBound.x-h.x))),y=m(c-1,Math.floor(p*(i.upperBound.y-h.y))),v=m(d-1,Math.floor(f*(i.upperBound.z-h.z)));for(let t=o;t<=g;t++)for(let i=n;i<=y;i++)for(let s=r;s<=v;s++){const o=t*l*c+i*c+s;r[o][this.binLengths[o]++]=e}}for(let t=0;t<r.length;t++){const s=this.binLengths[t];if(s>1){const o=r[t];for(let n=0;n<s;n++){const r=o[n];for(let h=0;h<n;h++){const s=o[h];this.needBroadphaseCollision(r,s)&&e.push(r,s)}}}}this.makePairsUnique(e,i);for(let t=0;t<r.length;t++)this.binLengths[t]=0;return e}},t.HingeConstraint=H,t.LockConstraint=class extends W{constructor(t,e,i){const s=(i=i||{}).maxForce?i.maxForce:1e6;super(t,e,i);const o=this.rotationalEquation1=new G(t,e,{maxForce:s}),n=this.rotationalEquation2=new G(t,e,{maxForce:s}),r=this.rotationalEquation3=new G(t,e,{maxForce:s});this.equations.push(o,n,r)}update(){const t=this.bodyA,e=this.bodyB,i=this.rotationalEquation1,s=this.rotationalEquation2,o=this.rotationalEquation3;super.update(),t.quaternion.vmult(n.UNIT_X,i.axisA),e.quaternion.vmult(n.UNIT_Y,i.axisB),t.quaternion.vmult(n.UNIT_Y,s.axisA),e.quaternion.vmult(n.UNIT_Z,s.axisB),t.quaternion.vmult(n.UNIT_Z,o.axisA),e.quaternion.vmult(n.UNIT_X,o.axisB)}},t.Mat3=l,t.Material=s,t.NaiveBroadphase=class extends e{constructor(){super(...arguments)}collisionPairs(t,e,i){const s=t.bodies,o=s.length;let n,r;for(n=0;n<o;n++)for(r=0;r<n;r++)this.needBroadphaseCollision(s[n],s[r])&&this.intersectionTest(s[n],s[r],e,i);return e}},t.ObjectCollisionMatrix=ct,t.POINTER_TYPES=G,t.PointToPointConstraint=W,t.Pool=S,t.Quaternion=h,t.RAY_MODES=wt,t.Ray=class{constructor(t,e){this.from=t?t.clone():new n,this.to=e?e.clone():new n,this._direction=new n,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=wt.ANY,this.result=new Ct,this.hasHit=!1,this.callback=(t=>{this.hasHit=!0,this.result=t})}get(t,e,i){i.vsub(t,this._direction),e.copy(i)}},t.RaycastResult=Ct,t.RaycastVehicle=class{constructor(t){this.chassisBody=t.chassisBody,this.wheelInfos=t.wheelInfos,this.sliding=!1,this.world=null,this.indexRightAxis=void 0!==t.indexRightAxis?t.indexRightAxis:1,this.indexForwardAxis=void 0!==t.indexForwardAxis?t.indexForwardAxis:0,this.indexUpAxis=void 0!==t.indexUpAxis?t.indexUpAxis:2,this.constraints=[],this.preStepCallback=()=>{const t=this.chassisBody,e=t.world,i=e.dt;for(let s=0;s<this.wheelInfos.length;s++){const o=this.wheelInfos[s],n=o.raycastResult;if(o.isInContact)o.suspensionLength=o.suspensionRestLength-n.distance;else{o.suspensionLength=o.suspensionRestLength;continue}const r=o.suspensionStiffness,h=o.suspensionRestLength,a=o.dampingRelaxation,l=o.dampingCompression,c=o.suspensionLength,d=r*(h-c);let u;const p=n.hitNormalWorld,f=n.hitPointWorld;t.getVelocityAtWorldPoint(f,B.vel);const m=p.dot(B.vel);if(m>0?u=l:u=a,t.velocity.vsub(o.chassisConnectionPointLocal,B.v),t.angularVelocity.cross(o.chassisConnectionPointLocal,B.v),t.velocity.vadd(B.v,B.v),o.suspensionForce=d-u*m*r,o.suspensionForce>o.maxSuspensionForce&&(o.suspensionForce=o.maxSuspensionForce),p.scale(-o.suspensionForce*i,B.impulse),f.vsub(t.position,B.point),t.applyImpulse(B.impulse,B.point)}}this.postStepCallback=()=>{for(let t=0;t<this.wheelInfos.length;t++){const e=this.wheelInfos[t];e.updateWheel(this.chassisBody)}}}addToWorld(t){this.constraints=[],t.add(this.chassisBody);const e=()=>{this.preStepCallback()};t.addEventListener("preStep",e),this.world=t;for(let i=0;i<this.wheelInfos.length;i++){const s=this.wheelInfos[i],o=new W(this.chassisBody,s.chassisConnectionPointLocal,{maxForce:s.maxSuspensionForce});t.addConstraint(o),this.constraints.push(o)}}getWheelSpeed(t){return this.wheelInfos[t].speed}setSteeringValue(t,e){this.wheelInfos[e].steering=t}setMotorSpeed(t,e){this.wheelInfos[e].engineForce=t*this.wheelInfos[e].maxForce}setBrake(t,e){t>0?(this.wheelInfos[e].brake=t,this.wheelInfos[e].engineForce=0):this.wheelInfos[e].brake=0}},t.RigidVehicle=class{constructor(t){this.wheelBodies=[],this.coordinateSystem=void 0===t.coordinateSystem?new n(1,2,3):t.coordinateSystem.clone(),this.chassisBody=t.chassisBody,this.constraints=[],this.wheelAxes=[],this.wheelForces=[];const e=new H(this.chassisBody,this.wheelBodies[0],{pivotA:new n,pivotB:new n,axisA:new n,axisB:new n}),i=new q(this.chassisBody,this.wheelBodies[0],{maxForce:1e6});this.constraints.push(e,i)}addWheel(t){const e=t.body;e.collisionFilterGroup=0;const i=this.wheelBodies;i.push(e),this.wheelForces.push(0);const s=i.length-1,o=new H(this.chassisBody,e,{pivotA:t.position.clone(),pivotB:new n(0,0,0),axisA:t.axis.clone(),axisB:new n(0,0,1),collideConnected:void 0===t.collideConnected||t.collideConnected}),r=new q(this.chassisBody,e,{maxForce:1e6});this.constraints.push(o),this.constraints.push(r)}setSteeringValue(t,e){const i=this.constraints[2*e],s=Math.sin(t),o=Math.cos(t),n=i.axisB.x,r=i.axisB.y;i.axisB.x=o*n-s*r,i.axisB.y=s*n+o*r}setMotorSpeed(t,e){const i=this.constraints[2*e];i.motor.enabled=!0,i.motor.targetVelocity=t}disableMotor(t){this.constraints[2*t].motor.enabled=!1}setWheelForce(t,e){this.wheelForces[e]=t}applyWheelForce(t,e){const i=this.wheelBodies[e],s=i.torque;this.constraints[2*e].axisA.scale(t,s),i.torque.vadd(s,i.torque)}addToWorld(t){const e=this.constraints,i=this.wheelBodies;t.add(this.chassisBody);for(let s=0;s<i.length;s++)t.add(i[s]),t.addConstraint(e[2*s]),t.addConstraint(e[2*s+1]);const s=()=>{for(let t=0;t<this.wheelForces.length;t++)this.applyWheelForce(this.wheelForces[t],t)};t.addEventListener("preStep",s),this.world=t}removeFromWorld(t){const e=this.constraints,i=this.wheelBodies;t.remove(this.chassisBody);for(let s=0;s<i.length;s++)t.remove(i[s]),t.removeConstraint(e[2*s]),t.removeConstraint(e[2*s+1])}getWheelSpeed(t){return this.wheelBodies[t].angularVelocity.dot(this.constraints[2*t].axisA)}},t.RotationalEquation=G,t.RotationalMotorEquation=class extends R{constructor(t,e,i){i=void 0!==i?i:1e6,super(-i,i),this.axisA=new n,this.axisB=new n,this.targetVelocity=0}computeB(t,e,i){return this.b*(this.computeGW()-this.targetVelocity)-this.a*this.computeGq()}},t.SAPBroadphase=class extends e{constructor(t){super(),this.axisList=[],this.world=null,this.axisIndex=0;const e=this.axisList;this._addBodyHandler=t=>{e.push(t)},this._removeBodyHandler=t=>{const i=e.indexOf(t);-1!==i&&e.splice(i,1)},t&&(this.setWorld(t))}setWorld(t){this.axisList.length=0;for(let e=0;e<t.bodies.length;e++)this.axisList.push(t.bodies[e]);t.removeEventListener("addBody",this._addBodyHandler),t.removeEventListener("removeBody",this._removeBodyHandler),t.addEventListener("addBody",this._addBodyHandler),t.addEventListener("removeBody",this._removeBodyHandler),this.world=t,this.dirty=!0}static insertionSortX(t){for(let e=1,i=t.length;e<i;e++){const i=t[e];let s;for(s=e-1;s>=0&&!(t[s].aabb.lowerBound.x>i.aabb.lowerBound.x);s--)t[s+1]=t[s];t[s+1]=i}}static insertionSortY(t){for(let e=1,i=t.length;e<i;e++){const i=t[e];let s;for(s=e-1;s>=0&&!(t[s].aabb.lowerBound.y>i.aabb.lowerBound.y);s--)t[s+1]=t[s];t[s+1]=i}}static insertionSortZ(t){for(let e=1,i=t.length;e<i;e++){const i=t[e];let s;for(s=e-1;s>=0&&!(t[s].aabb.lowerBound.z>i.aabb.lowerBound.z);s--)t[s+1]=t[s];t[s+1]=i}}collisionPairs(t,e,i){const s=this.axisList,o=s.length,n=this.axisIndex;if(this.dirty){this.sortList();const e=t.bodies;for(let t=0;t<e.length;t++){e[t].aabbNeedsUpdate&&e[t].updateAABB()}this.dirty=!1}let r,h,a,l;for(r=0;r!==o;r++){const t=s[r];for(h=r+1;h<o;h++){if(a=s[h],(l=a.aabb.lowerBound[ft[n]])>t.aabb.upperBound[ft[n]])break;this.needBroadphaseCollision(t,a)&&this.intersectionTest(t,a,e,i)}}this.makePairsUnique(e,i)}sortList(){const t=this.axisList,e=this.axisIndex;for(let e=0;e<t.length;e++){const i=t[e];i.aabbNeedsUpdate&&i.updateAABB()}0===e?this.constructor.insertionSortX(t):1===e?this.constructor.insertionSortY(t):2===e&&this.constructor.insertionSortZ(t)}autoDetectAxis(){let t=0,e=0,i=0;const s=this.axisList;for(let o=0;o<s.length;o++){const n=s[o],r=n.aabb.upperBound.x-n.aabb.lowerBound.x,h=n.aabb.upperBound.y-n.aabb.lowerBound.y,a=n.aabb.upperBound.z-n.aabb.lowerBound.z;t+=r*r,e+=h*h,i+=a*a}this.axisIndex=t>e?t>i?0:2:e>i?1:2}aabbQuery(t,e,i){i=i||[];const s=t.bodies,o=this.axisList;let n=0;if(this.dirty){this.sortList();const e=t.bodies;for(let t=0;t<e.length;t++){e[t].aabbNeedsUpdate&&e[t].updateAABB()}this.dirty=!1}const r=e.lowerBound[ft[this.axisIndex]];for(;n<o.length;n++){const t=o[n];if(t.aabb.lowerBound[ft[this.axisIndex]]>r)break;t.aabb.overlaps(e)&&i.push(t)}return i}},t.SHAPE_TYPES=v,t.Shape=v,t.Solver=class{constructor(){this.equations=[]}solve(t,e){return 0}add(t){this.equations.push(t)}remove(t){const e=this.equations.indexOf(t);-1!==e&&this.equations.splice(e,1)}removeAll(){this.equations.length=0}},t.Sphere=C,t.SplitSolver=class extends ot{constructor(t){super(),this.subsolver=t,this.nodes=[],this.nodePool=new S({size:128}),this.equations=[]}add(t){this.equations.push(t)}remove(t){const e=this.equations.indexOf(t);-1!==e&&this.equations.splice(e,1)}solve(t,e){const i=this.nodePool,s=e.bodies,o=this.equations,n=o.length,r=s.length,h=this.subsolver;for(;i.size<r;)i.resize(2*i.size);const a=i.elements;for(let t=0;t<r;t++){const e=a[t];e.body=s[t],e.children=[],e.eq=[],e.visited=!1}for(let t=0;t<n;t++){const e=o[t],i=s.indexOf(e.bi),r=s.indexOf(e.bj),h=a[i],l=a[r];h.eq.push(e),l.eq.push(e),h.children.push(l),l.children.push(h)}let l,c=0,d=i.get();for(d.body=null,d.visited=!0,this.bfs(d, (t,e,i)=>{c++;for(let t=0;t<e.length;t++)s[e[t]].solve_island=c});c--;){const t=[];for(let e=0;e<r;e++)s[e].solve_island===c+1&&t.push(s[e]);if(t.length){h.solve(t,e)}}}},t.Spring=G,t.Trimesh=F,t.TupleDictionary=class{constructor(){this.data={keys:[]}}get(t,e){if(t>e){const i=e;e=t,t=i}const s=`${t}-${e}`;return this.data[s]}set(t,e,i){if(t>e){const s=e;e=t,t=s}const o=`${t}-${e}`;if(!this.get(t,e))this.data.keys.push(o);this.data[o]=i}reset(){const t=this.data,e=t.keys;for(;e.length>0;){delete t[e.pop()]}t.keys=[]}},t.Vec3=n,t.World=Gt,Object.defineProperty(t,"__esModule",{value:!0})}));
    // --- END CANNON-ES.JS LIBRARY CODE ---
    </script>

    <!-- CSS 样式 -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #1a2a52;
        }

        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: #fff;
            pointer-events: none;
            box-sizing: border-box;
            display: none;
        }

        #ui-hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
        }

        #timer {
            font-size: 1.8em;
        }

        #lives span {
            margin-left: 5px;
            font-size: 1.2em;
        }

        .overlay {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(25, 42, 86, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            pointer-events: all;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
        }

        .overlay.active {
            display: flex;
            opacity: 1;
        }


        .overlay h1 {
            font-size: 3.5em;
            margin-bottom: 0.2em;
            color: #ffc107;
        }

        .overlay h2 {
            font-size: 3em;
            margin-bottom: 0.5em;
        }

        .overlay p {
            font-size: 1.1em;
            max-width: 85%;
            line-height: 1.6;
            margin-bottom: 1.5em;
        }

        .overlay button {
            padding: 18px 45px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 50px;
            background: linear-gradient(145deg, #ff8a00, #e52e71);
            color: white;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.2s ease;
            margin-top: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .overlay button:active {
            transform: scale(0.96);
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .high-score {
            margin-top: 2em;
            font-size: 1.1em;
            opacity: 0.8;
        }
        
        .version-text {
            position: absolute;
            bottom: 20px;
            font-size: 0.9em;
            opacity: 0.6;
        }

        #game-controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            pointer-events: all;
        }

        #pause-button {
            width: 60px;
            height: 60px;
            font-size: 1.5em;
            border: 3px solid white;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.3);
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #pause-button:active {
            background-color: rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <!-- 3D渲染画布 -->
    <div id="game-canvas"></div>

    <!-- UI层: 游戏界面 (HUD) -->
    <div id="ui-hud" class="ui-layer">
        <div id="score">Score: 0</div>
        <div id="timer">01:00</div>
        <div id="lives"></div>
    </div>

    <!-- UI层: 开始菜单界面 -->
    <div id="ui-menu" class="ui-layer overlay active">
        <h1>Cosmic Roll</h1>
        <p>
            <b>电脑:</b> 使用 W/A/S/D 或方向键移动<br>
            <b>手机:</b> 倾斜你的设备来移动小球<br><br>
            在时间耗尽前，收集所有星星并到达终点！
        </p>
        <button id="start-button">开始游戏</button>
        <div class="high-score">最高分: <span id="high-score">0</span></div>
        <div class="version-text">版本 1.2</div>
    </div>
    
    <!-- UI层: 暂停界面 -->
    <div id="ui-pause" class="ui-layer overlay">
        <h2>已暂停</h2>
        <button id="resume-button">继续</button>
        <button id="restart-button-pause">重新开始</button>
    </div>

    <!-- UI层: 失败界面 -->
    <div id="ui-gameover" class="ui-layer overlay">
        <h2>游戏结束</h2>
        <p>你的得分: <span id="final-score">0</span></p>
        <button id="restart-button-gameover">再玩一次</button>
    </div>

    <!-- UI层: 胜利界面 -->
    <div id="ui-win" class="ui-layer overlay">
        <h2>闯关成功!</h2>
        <p>最终得分: <span id="win-score">0</span></p>
        <button id="play-next-level-button">再玩一次</button>
    </div>
    
    <!-- 游戏内控制按钮 (用于手机端暂停) -->
    <div id="game-controls">
      <button id="pause-button">❚❚</button>
    </div>

    <!-- JavaScript 游戏逻辑 -->
    <script>
        window.addEventListener('load', () => {
            try {
                // 现在 THREE 和 CANNON 都已经加载完毕
                new Game();
            } catch (error) {
                console.error("无法初始化游戏:", error);
                alert("抱歉，游戏无法初始化。\n错误详情: " + error.message);
            }
        });

        class Game {
            constructor() {
                this.initEngine();
                this.initUI();
                this.addEventListeners();
                this.showMenu();
            }

            initEngine() {
                this.gameState = 'MENU';
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-canvas').appendChild(this.renderer.domElement);

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x334d7c);
                this.scene.fog = new THREE.Fog(0x334d7c, 30, 60);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 10, 15);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                this.scene.add(ambientLight);
                this.light = new THREE.DirectionalLight(0xffffff, 0.8);
                this.light.position.set(10, 20, 5);
                this.light.castShadow = true;
                this.light.shadow.mapSize.width = 2048;
                this.light.shadow.mapSize.height = 2048;
                this.scene.add(this.light);

                this.physicsWorld = new CANNON.World({ gravity: new CANNON.Vec3(0, -30, 0) });
                this.clock = new THREE.Clock();
                this.dynamicObjects = [];
            }
            
            startGame() {
                try {
                    this.resetGame();
                    this.initLevel();

                    this.gameState = 'PLAYING';
                    this.updateUI();

                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                            .then(permissionState => {
                                if (permissionState === 'granted') {
                                    window.addEventListener('deviceorientation', this.handleOrientation);
                                }
                            }).catch(console.error);
                    } else {
                        window.addEventListener('deviceorientation', this.handleOrientation);
                    }

                    this.timerInterval = setInterval(() => this.updateTimer(), 1000);
                    this.animate();
                } catch (error) {
                    console.error("启动游戏时出错:", error);
                    alert("启动游戏时发生错误，请刷新页面重试。\n错误: " + error.message);
                    this.showMenu();
                }
            }
            
            resetGame() {
                this.dynamicObjects.forEach(obj => {
                    if (obj.mesh) this.scene.remove(obj.mesh);
                    if (obj.body) {
                        obj.body.removeEventListener('collide', this.handleCollision);
                        this.physicsWorld.removeBody(obj.body);
                    }
                });
                this.dynamicObjects = [];
                
                if (this.ballBody) {
                    this.ballBody.removeEventListener('collide', this.handleCollision);
                }

                if(this.timerInterval) clearInterval(this.timerInterval);
                if(this.animationFrameId) cancelAnimationFrame(this.animationFrameId);

                this.score = 0;
                this.lives = 3;
                this.timeLeft = 60;
                this.gyro = { beta: 0, gamma: 0 };
                this.keysPressed = {};
                
                this.handleOrientation = this.handleOrientation.bind(this);
                this.handleCollision = this.handleCollision.bind(this);
                window.removeEventListener('deviceorientation', this.handleOrientation);
            }
            
            initLevel() {
                const platformMaterial = new CANNON.Material('platform');
                const levelLayout = [
                    { size: [10, 1, 10], position: [0, 0, 0] }, { size: [10, 1, 4], position: [0, 0, -7] },
                    { size: [4, 1, 10], position: [7, 0, -12] }, { size: [15, 1, 4], position: [15, -2, -12], isSlanted: true },
                    { size: [4, 1, 10], position: [23, -4, -12] }, { size: [10, 1, 4], position: [23, -4, -5] },
                ];

                levelLayout.forEach(data => {
                    const mesh = new THREE.Mesh( new THREE.BoxGeometry(data.size[0], data.size[1], data.size[2]), new THREE.MeshStandardMaterial({ color: 0x4466aa, roughness: 0.8 }) );
                    mesh.position.set(data.position[0], data.position[1], data.position[2]);
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    const body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(data.size[0]/2, data.size[1]/2, data.size[2]/2)), position: new CANNON.Vec3(data.position[0], data.position[1], data.position[2]), material: platformMaterial });
                    if(data.isSlanted) { body.quaternion.setFromEuler(-Math.PI / 16, 0, 0); mesh.quaternion.copy(body.quaternion); }
                    this.physicsWorld.addBody(body);
                    this.dynamicObjects.push({mesh, body});
                });
                
                this.createBall(platformMaterial);
                this.createStars();
                this.createFinishZone();
            }

            createBall(platformMaterial) {
                const ballMaterial = new CANNON.Material('ball');
                this.ballMesh = new THREE.Mesh( new THREE.SphereGeometry(0.5, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.3, roughness: 0.4 }) );
                this.ballMesh.castShadow = true;
                this.scene.add(this.ballMesh);

                this.ballBody = new CANNON.Body({ mass: 1.5, shape: new CANNON.Sphere(0.5), position: new CANNON.Vec3(0, 2, 0), material: ballMaterial });
                this.ballBody.addEventListener('collide', this.handleCollision);
                this.physicsWorld.addBody(this.ballBody);
                this.dynamicObjects.push({mesh: this.ballMesh, body: this.ballBody});
                
                const ballPlatformContact = new CANNON.ContactMaterial(ballMaterial, platformMaterial, { friction: 0.1, restitution: 0.3 });
                this.physicsWorld.addContactMaterial(ballPlatformContact);
            }
            
            createStars() {
                const starGeo = new THREE.TorusGeometry(0.4, 0.15, 8, 5);
                const starMat = new THREE.MeshStandardMaterial({ color: 0xffe066, emissive: 0xffc107, emissiveIntensity: 0.6 });
                const starPositions = [ [0, 1.5, -7], [7, 1.5, -9], [7, 1.5, -15], [15, 0.5, -12], [23, -2.5, -15], [23, -2.5, -9] ];

                starPositions.forEach(pos => {
                    const mesh = new THREE.Mesh(starGeo, starMat);
                    mesh.position.set(pos[0], pos[1], pos[2]);
                    mesh.castShadow = true;
                    this.scene.add(mesh);
                    const body = new CANNON.Body({ isTrigger: true, mass: 0, shape: new CANNON.Sphere(0.7), position: new CANNON.Vec3(pos[0], pos[1], pos[2]) });
                    body.isStar = true; 
                    body.starMesh = mesh;
                    this.physicsWorld.addBody(body);
                    this.dynamicObjects.push({mesh, body});
                });
            }

            createFinishZone() {
                const finishMesh = new THREE.Mesh( new THREE.CylinderGeometry(2, 2, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }) );
                finishMesh.position.set(23, -3.9, -5);
                this.scene.add(finishMesh);

                const finishBody = new CANNON.Body({ isTrigger: true, mass: 0, shape: new CANNON.Cylinder(2, 2, 0.2, 12), position: new CANNON.Vec3(23, -3.9, -5) });
                finishBody.isFinish = true;
                this.physicsWorld.addBody(finishBody);
                this.dynamicObjects.push({mesh: finishMesh, body: finishBody});
            }

            animate() {
                this.animationFrameId = requestAnimationFrame(() => this.animate());
                
                if (this.gameState === 'PLAYING') {
                    const deltaTime = Math.min(this.clock.getDelta(), 0.1);
                    this.physicsWorld.step(1 / 60, deltaTime, 3);
                    
                    this.applyForces();

                    this.ballMesh.position.copy(this.ballBody.position);
                    this.ballMesh.quaternion.copy(this.ballBody.quaternion);
                    
                    this.dynamicObjects.forEach(obj => {
                        if (obj.body.isStar && obj.mesh && obj.mesh.visible) obj.mesh.rotation.y += 0.02;
                    });

                    this.updateCamera();
                    this.checkFall();
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            applyForces() {
                const forceMagnitude = 60;
                let force = new CANNON.Vec3( this.gyro.gamma / 90 * forceMagnitude, 0, this.gyro.beta / 90 * forceMagnitude );
                
                if (this.keysPressed.w || this.keysPressed.arrowup) force.z = -forceMagnitude;
                if (this.keysPressed.s || this.keysPressed.arrowdown) force.z = forceMagnitude;
                if (this.keysPressed.a || this.keysPressed.arrowleft) force.x = -forceMagnitude;
                if (this.keysPressed.d || this.keysPressed.arrowright) force.x = forceMagnitude;
                
                if (force.x !== 0 || force.z !== 0) {
                    this.ballBody.applyForce(force, this.ballBody.position);
                }
            }

            updateCamera() {
                const offset = new THREE.Vector3(0, 8, 10);
                const targetPosition = this.ballMesh.position.clone().add(offset);
                this.camera.position.lerp(targetPosition, 0.05);
                this.camera.lookAt(this.ballMesh.position);
                this.light.position.copy(this.camera.position).add(new THREE.Vector3(-5, 5, -5));
                this.light.target = this.ballMesh;
            }

            handleCollision(event) {
                const body = event.body;
                if (body.isStar && !body.isCollected) {
                    body.isCollected = true;
                    this.score += 10;
                    body.starMesh.visible = false;
                    this.updateUI();
                }
                if (body.isFinish) this.winGame();
            }

            checkFall() {
                if (this.ballBody.position.y < -20) {
                    this.lives--;
                    this.updateUI();
                    if (this.lives <= 0) this.gameOver();
                    else this.resetBallPosition();
                }
            }

            resetBallPosition() {
                this.ballBody.velocity.set(0, 0, 0);
                this.ballBody.angularVelocity.set(0, 0, 0);
                this.ballBody.position.set(0, 2, 0);
            }

            updateTimer() {
                if(this.gameState !== 'PLAYING') return;
                this.timeLeft--;
                this.updateUI();
                if (this.timeLeft <= 0) this.gameOver();
            }
            
            gameOver() {
                if (this.gameState !== 'PLAYING') return;
                this.gameState = 'GAMEOVER';
                clearInterval(this.timerInterval);
                this.updateUI();
            }

            winGame() {
                if (this.gameState !== 'PLAYING') return;
                this.gameState = 'WIN';
                clearInterval(this.timerInterval);
                this.score += this.timeLeft * 5;
                this.updateUI();
            }

            pauseGame() {
                if(this.gameState !== 'PLAYING') return;
                this.gameState = 'PAUSED';
                this.updateUI();
            }

            resumeGame() {
                if(this.gameState !== 'PAUSED') return;
                this.gameState = 'PLAYING';
                this.updateUI();
            }
            
            initUI() {
                this.ui = {
                    hud: document.getElementById('ui-hud'), menu: document.getElementById('ui-menu'),
                    pause: document.getElementById('ui-pause'), gameover: document.getElementById('ui-gameover'),
                    win: document.getElementById('ui-win'), score: document.getElementById('score'),
                    timer: document.getElementById('timer'), lives: document.getElementById('lives'),
                    finalScore: document.getElementById('final-score'), winScore: document.getElementById('win-score'),
                    highScore: document.getElementById('high-score'),
                };
                this.highScore = localStorage.getItem('highScore') || 0;
                this.ui.highScore.textContent = this.highScore;
            }
            
            updateUI() {
                Object.values(this.ui).forEach(el => el.classList?.remove('active'));
                this.ui.hud.style.display = 'none';
                document.getElementById('game-controls').style.display = 'none';

                switch(this.gameState) {
                    case 'MENU':
                        this.ui.menu.classList.add('active');
                        break;
                    case 'PLAYING':
                    case 'PAUSED':
                        this.ui.hud.style.display = 'flex';
                        document.getElementById('game-controls').style.display = 'block';
                        this.ui.score.textContent = `得分: ${this.score}`;
                        const minutes = Math.floor(this.timeLeft / 60).toString().padStart(2, '0');
                        const seconds = (this.timeLeft % 60).toString().padStart(2, '0');
                        this.ui.timer.textContent = `${minutes}:${seconds}`;
                        this.ui.lives.innerHTML = '❤️'.repeat(this.lives);
                        if (this.gameState === 'PAUSED') this.ui.pause.classList.add('active');
                        break;
                    case 'GAMEOVER':
                        this.ui.gameover.classList.add('active');
                        this.ui.finalScore.textContent = this.score;
                        this.updateHighScore();
                        break;
                    case 'WIN':
                        this.ui.win.classList.add('active');
                        this.ui.winScore.textContent = this.score;
                        this.updateHighScore();
                        break;
                }
            }
            
            showMenu() { this.gameState = 'MENU'; this.updateUI(); }
            
            updateHighScore() {
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('highScore', this.highScore);
                    this.ui.highScore.textContent = this.highScore;
                }
            }

            addEventListeners() {
                document.getElementById('start-button').addEventListener('click', () => this.startGame());
                document.getElementById('pause-button').addEventListener('click', () => this.pauseGame());
                document.getElementById('resume-button').addEventListener('click', () => this.resumeGame());
                
                [document.getElementById('restart-button-pause'), document.getElementById('restart-button-gameover'), document.getElementById('play-next-level-button')]
                .forEach(btn => btn.addEventListener('click', () => this.startGame()));
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                window.addEventListener('keydown', (event) => { this.keysPressed[event.key.toLowerCase()] = true; });
                window.addEventListener('keyup', (event) => { this.keysPressed[event.key.toLowerCase()] = false; });
            }
            
            handleOrientation(event) {
                this.gyro.beta = event.beta ? Math.max(-90, Math.min(90, event.beta)) : 0;
                this.gyro.gamma = event.gamma ? Math.max(-90, Math.min(90, event.gamma)) : 0;
            }
        }
    </script>
</body>
</html>
